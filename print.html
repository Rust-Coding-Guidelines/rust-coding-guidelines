<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust Coding Specification V1.0 beta</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/overview/why.html"><strong aria-hidden="true">1.1.</strong> Why you need the Rust coding specification </a></li><li class="chapter-item "><a href="safe-guides/overview/convention.html"><strong aria-hidden="true">1.2.</strong> Basic conventions of the coding specification</a></li></ol></li><li class="chapter-item "><a href="safe-guides/code_style.html"><strong aria-hidden="true">2.</strong> Coding Style</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/naming.html"><strong aria-hidden="true">2.1.</strong> Naming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.01.html"><strong aria-hidden="true">2.1.1.</strong> P.NAM.01 The naming convention for identifiers in the same crate should use a uniform word order</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.02.html"><strong aria-hidden="true">2.1.2.</strong> P.NAM.02 Names for cargo features should not contain meaningless placeholders</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.03.html"><strong aria-hidden="true">2.1.3.</strong> P.NAM.03 Identifier naming should be in line with reading habits</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.04.html"><strong aria-hidden="true">2.1.4.</strong> P.NAM.04 The larger the scope, the more precise the naming, and the opposite should be short</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.05.html"><strong aria-hidden="true">2.1.5.</strong> P.NAM.05 The getter family of methods used to access or retrieve data should not normally have the prefix get_</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.06.html"><strong aria-hidden="true">2.1.6.</strong> P.NAM.06 Follow the iter/ iter_mut/ into_iter specification to generate iterators</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.07.html"><strong aria-hidden="true">2.1.7.</strong> P.NAM.07 Avoid using special names such as language built-in reserved words, keywords, built-in types and traits</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.08.html"><strong aria-hidden="true">2.1.8.</strong> P.NAM.08 Avoid adding type identifiers to the naming of variables</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/P.NAM.09.html"><strong aria-hidden="true">2.1.9.</strong> P.NAM.09 Global static variables should be defined with the prefix G_ to distinguish them from constants</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.01.html"><strong aria-hidden="true">2.1.10.</strong> G.NAM.01 Use a uniform naming style</a></li><li class="chapter-item "><a href="safe-guides/code_style/naming/G.NAM.02.html"><strong aria-hidden="true">2.1.11.</strong> G.NAM.02 Type conversion function naming needs to follow ownership semantics</a></li></ol></li><li class="chapter-item "><a href="safe-guides/code_style/fmt.html"><strong aria-hidden="true">2.2.</strong> Format</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.01.html"><strong aria-hidden="true">2.2.1.</strong> P.FMT.01 Automatic code formatting with rustfmt</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.02.html"><strong aria-hidden="true">2.2.2.</strong> P.FMT.02 Use spaces instead of tabs for indentation</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.03.html"><strong aria-hidden="true">2.2.3.</strong> P.FMT.03 The maximum width of line spacing is one blank line</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.04.html"><strong aria-hidden="true">2.2.4.</strong> P.FMT.04 Language items should be defined with the left  braces position on the same line </a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.05.html"><strong aria-hidden="true">2.2.5.</strong> P.FMT.05 Block indentation should be maintained when multiple identifiers are present</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.06.html"><strong aria-hidden="true">2.2.6.</strong> P.FMT.06 When there is a multi-line expression operation, the operator should be placed at the beginning of the line</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.07.html"><strong aria-hidden="true">2.2.7.</strong> P.FMT.07 Both enumeration variants and structure fields should be left aligned</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.08.html"><strong aria-hidden="true">2.2.8.</strong> P.FMT.08 Line feeds for functions with more than five parameters or imported modules with more than four parameters</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.09.html"><strong aria-hidden="true">2.2.9.</strong> P.FMT.09 Use different spaces style for different scenarios</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.10.html"><strong aria-hidden="true">2.2.10.</strong> P.FMT.10 match arms should have good readability</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.11.html"><strong aria-hidden="true">2.2.11.</strong> P.FMT.11 Imported modules should be grouped with good readability</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.12.html"><strong aria-hidden="true">2.2.12.</strong> P.FMT.12 Declarative macros arms should be well readable</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.13.html"><strong aria-hidden="true">2.2.13.</strong> P.FMT.13 Do not omit field names when initializing named structure fields</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.14.html"><strong aria-hidden="true">2.2.14.</strong> P.FMT.14 extern external functions need to be explicitly specified C-ABI</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.15.html"><strong aria-hidden="true">2.2.15.</strong> P.FMT.15 Deconstructing a tuple allows the use of ..  to refer to the remaining elements</a></li><li class="chapter-item "><a href="safe-guides/code_style/fmt/P.FMT.16.html"><strong aria-hidden="true">2.2.16.</strong> P.FMT.16 Do not merge multiple unrelated traits in derived macros into the same line</a></li></ol></li><li class="chapter-item "><a href="safe-guides/code_style/comments.html"><strong aria-hidden="true">2.3.</strong> Code Comments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.01.html"><strong aria-hidden="true">2.3.1.</strong> P.CMT.01 The code can be self-commenting and the documentation should be concise.</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.02.html"><strong aria-hidden="true">2.3.2.</strong> P.CMT.02 Comments should have a width limit</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.03.html"><strong aria-hidden="true">2.3.3.</strong> P.CMT.03 Use line comments and avoid block comments</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.04.html"><strong aria-hidden="true">2.3.4.</strong> P.CMT.04 File header comments include a copyright notice</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/P.CMT.05.html"><strong aria-hidden="true">2.3.5.</strong> P.CMT.05 Use FIXME and TODO in comments to help with team collaboration</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.01.html"><strong aria-hidden="true">2.3.6.</strong> G.CMT.01 Error comments need to be added to the documentation of functions that return Result types in the public</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.02.html"><strong aria-hidden="true">2.3.7.</strong> G.CMT.02 If a Panic occurs under certain circumstances in the public API, add a Panic comment to the corresponding document</a></li><li class="chapter-item "><a href="safe-guides/code_style/comments/G.CMT.03.html"><strong aria-hidden="true">2.3.8.</strong> G.CMT.03 Use spaces in document comments instead of tabs</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice.html"><strong aria-hidden="true">3.</strong> Coding Practice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/consts.html"><strong aria-hidden="true">3.1.</strong> Const</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.01.html"><strong aria-hidden="true">3.1.1.</strong> G.CNS.01 Use predefined consts for float approximation in scientific computation</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.02.html"><strong aria-hidden="true">3.1.2.</strong> G.CNS.02 Shouldn't assert const bool type</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.03.html"><strong aria-hidden="true">3.1.3.</strong> G.CNS.03 Shouldn't declare interior mutable container as consts</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.04.html"><strong aria-hidden="true">3.1.4.</strong> G.CNS.04 不应在常量定义中增加显式的 'static 生命周期</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/consts/G.CNS.05.html"><strong aria-hidden="true">3.1.5.</strong> G.CNS.05 对于适用 const fn 的函数或方法宜尽可能地使用 const fn</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/statics.html"><strong aria-hidden="true">3.2.</strong> Static Const</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/statics/G.STV.01.html"><strong aria-hidden="true">3.2.1.</strong> G.STV.01 不宜直接使用可变静态变量作为全局变量</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables.html"><strong aria-hidden="true">3.3.</strong> Local Const</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/variables/P.VAR.01.html"><strong aria-hidden="true">3.3.1.</strong> P.VAR.01 一般情况下避免先声明可变变量再赋值</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/P.VAR.02.html"><strong aria-hidden="true">3.3.2.</strong> P.VAR.02 利用变量遮蔽功能保证变量安全使用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.01.html"><strong aria-hidden="true">3.3.3.</strong> G.VAR.01 以解构元组方式定义超过四个变量时不应使用太多无意义变量名</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.02.html"><strong aria-hidden="true">3.3.4.</strong> G.VAR.02 不应使用非 ASCII 字符作为标识符</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.03.html"><strong aria-hidden="true">3.3.5.</strong> G.VAR.03 变量遮蔽功能应当合理使用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/variables/G.VAR.04.html"><strong aria-hidden="true">3.3.6.</strong> G.VAR.04 避免因局部变量过大而导致的大量栈分配</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type.html"><strong aria-hidden="true">3.4.</strong> Data Type</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/P.TYP.01.html"><strong aria-hidden="true">3.4.1.</strong> P.TYP.01 必要时，应使类型可以表达更明确的语义，而不是只是直接使用原生类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/G.TYP.01.html"><strong aria-hidden="true">3.4.2.</strong> G.TYP.01 类型转换尽可能使用安全的转换函数代替 as</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/G.TYP.02.html"><strong aria-hidden="true">3.4.3.</strong> G.TYP.02 数字字面量在使用的时候应该明确标注类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/G.TYP.03.html"><strong aria-hidden="true">3.4.4.</strong> G.TYP.03 不要用数字类型边界值判断能否安全转换，而应使用 try_from 方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool.html"><strong aria-hidden="true">3.4.5.</strong> Bool</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.01.html"><strong aria-hidden="true">3.4.5.1.</strong> G.TYP.BOL.01 不应将布尔值和布尔字面量进行比较</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.02.html"><strong aria-hidden="true">3.4.5.2.</strong> G.TYP.BOL.02 如果 match 匹配表达式为布尔类型，宜使用 if 表达式来代替</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.03.html"><strong aria-hidden="true">3.4.5.3.</strong> G.TYP.BOL.03 不应将数字类型转换为布尔值</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.04.html"><strong aria-hidden="true">3.4.5.4.</strong> G.TYP.BOL.04 禁止在if表达式条件中使用块结构</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.05.html"><strong aria-hidden="true">3.4.5.5.</strong> G.TYP.BOL.05 非必要时，布尔运算应使用逻辑运算符( &amp;&amp;/||)而非位运算符 (&amp;/|)</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/bool/G.TYP.BOL.06.html"><strong aria-hidden="true">3.4.5.6.</strong> G.TYP.BOL.06 不应使用数字代替布尔值</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char.html"><strong aria-hidden="true">3.4.6.</strong> Character</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char/G.TYP.CHR.01.html"><strong aria-hidden="true">3.4.6.1.</strong> G.TYP.CHR.01 不应将字符字面量强制转换为 u8</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char/G.TYP.CHR.02.html"><strong aria-hidden="true">3.4.6.2.</strong> G.TYP.CHR.02 字符串方法中如果需要单个字符的值作为参数，宜使用字符而非字符串</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/char/G.TYP.CHR.03.html"><strong aria-hidden="true">3.4.6.3.</strong> G.TYP.CHR.03 需要将整数转换为字符时，应使用安全转换函数，而非 transmute</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int.html"><strong aria-hidden="true">3.4.7.</strong> Integer</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int/G.TYP.INT.01.html"><strong aria-hidden="true">3.4.7.1.</strong> G.TYP.INT.01 在用整数计算的时候需要考虑整数溢出、回绕和截断的风险</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int/G.TYP.INT.02.html"><strong aria-hidden="true">3.4.7.2.</strong> G.TYP.INT.02 避免在有符号整数和无符号整数之间进行强制转换</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/int/G.TYP.INT.03.html"><strong aria-hidden="true">3.4.7.3.</strong> G.TYP.INT.03 对负数取模计算的时候不应使用 %</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float.html"><strong aria-hidden="true">3.4.8.</strong> Float</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.01.html"><strong aria-hidden="true">3.4.8.1.</strong> G.TYP.FLT.01 使用浮点数字面量时，要警惕是否存在被Rust编译器截断的风险</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.02.html"><strong aria-hidden="true">3.4.8.2.</strong> G.TYP.FLT.02 从任何数字类型转换为浮点类型时注意避免损失精度</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.03.html"><strong aria-hidden="true">3.4.8.3.</strong> G.TYP.FLT.03 对精度高要求的场景下，使用浮点数进行运算和比较时需要注意精度损失</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.04.html"><strong aria-hidden="true">3.4.8.4.</strong> G.TYP.FLT.04 宜使用Rust内置方法处理浮点数计算</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/float/G.TYP.FLT.05.html"><strong aria-hidden="true">3.4.8.5.</strong> G.TYP.FLT.05 禁止在浮点数和整数相互转换时使用 transmute</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice.html"><strong aria-hidden="true">3.4.9.</strong> Slice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice/P.TYP.SLC.01.html"><strong aria-hidden="true">3.4.9.1.</strong> P.TYP.SLC.01 宜使用切片迭代器来代替手工索引</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/slice/P.TYP.SLC.02.html"><strong aria-hidden="true">3.4.9.2.</strong> P.TYP.SLC.02 宜使用切片模式来提升代码的可读性</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/tuple.html"><strong aria-hidden="true">3.4.10.</strong> Tuple</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/tuple/G.TYP.TUP.01.html"><strong aria-hidden="true">3.4.10.1.</strong> G.TYP.TUP.01 使用元组时，其元素不宜超过3个</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array.html"><strong aria-hidden="true">3.4.11.</strong> Array</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array/G.TYP.ARR.01.html"><strong aria-hidden="true">3.4.11.1.</strong> G.TYP.ARR.01 创建大全局数组时宜使用静态变量而非常量</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array/G.TYP.ARR.02.html"><strong aria-hidden="true">3.4.11.2.</strong> G.TYP.ARR.02 使用数组索引时禁止越界访问</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/array/G.TYP.ARR.03.html"><strong aria-hidden="true">3.4.11.3.</strong> G.TYP.ARR.03 当数组元素为原生数据类型（Primitive），排序时优先选用非稳定排序</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec.html"><strong aria-hidden="true">3.4.12.</strong> Vector</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec/P.TYP.VEC.01.html"><strong aria-hidden="true">3.4.12.1.</strong> P.TYP.VEC.01 非必要时不宜使用动态数组</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec/P.TYP.VEC.02.html"><strong aria-hidden="true">3.4.12.2.</strong> P.TYP.VEC.02 创建动态数组时，宜预先分配足够容量，避免后续操作中产生多次分配</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/vec/G.TYP.VEC.01.html"><strong aria-hidden="true">3.4.12.3.</strong> G.TYP.VEC.01 禁止访问未初始化的数组</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct.html"><strong aria-hidden="true">3.4.13.</strong> Struct</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/P.TYP.SCT.01.html"><strong aria-hidden="true">3.4.13.1.</strong> P.TYP.SCT.01 为结构体实现构造性方法时，避免构造后再初始化的情况</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/P.TYP.SCT.02.html"><strong aria-hidden="true">3.4.13.2.</strong> P.TYP.SCT.02 结构体实例需要默认实现时，宜使用Default特质</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/G.TYP.SCT.01.html"><strong aria-hidden="true">3.4.13.3.</strong> G.TYP.SCT.01 对外导出的公开的 Struct，宜添加#[non_exhaustive]属性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/G.TYP.SCT.02.html"><strong aria-hidden="true">3.4.13.4.</strong> G.TYP.SCT.02 当结构体中有超过三个布尔类型的字段，宜将其独立为新的枚举类</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/struct/G.TYP.SCT.03.html"><strong aria-hidden="true">3.4.13.5.</strong> G.TYP.SCT.03 宜使用结构体功能更新语法来提升代码可读性</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum.html"><strong aria-hidden="true">3.4.14.</strong> Enumeration</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.01.html"><strong aria-hidden="true">3.4.14.1.</strong> G.TYP.ENM.01 合理使用map和and_then方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.02.html"><strong aria-hidden="true">3.4.14.2.</strong> G.TYP.ENM.02 不应自行创建空枚举</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.03.html"><strong aria-hidden="true">3.4.14.3.</strong> G.TYP.ENM.03 在使用类似 C 语言的枚举写法且使用repr(isize/usize) 布局时注意 32位架构上截断的问题</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.04.html"><strong aria-hidden="true">3.4.14.4.</strong> G.TYP.ENM.04 不宜在use语句中引入Enum的全部变体（variants）</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.05.html"><strong aria-hidden="true">3.4.14.5.</strong> G.TYP.ENM.05 对外导出的公开Enum，宜添加#[non_exhaustive]属性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/data-type/enum/G.TYP.ENM.06.html"><strong aria-hidden="true">3.4.14.6.</strong> G.TYP.ENM.06 Enum内变体的大小差异不宜过大</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr.html"><strong aria-hidden="true">3.5.</strong> Express</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.01.html"><strong aria-hidden="true">3.5.1.</strong> G.EXP.01 当需要对表达式求值后重新赋值时，宜使用复合赋值模式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.02.html"><strong aria-hidden="true">3.5.2.</strong> G.EXP.02 不宜在比较中使用不兼容的位掩码</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.03.html"><strong aria-hidden="true">3.5.3.</strong> G.EXP.03 不应利用数组表达式的边界检查来 Panic，而应使用断言</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.04.html"><strong aria-hidden="true">3.5.4.</strong> G.EXP.04 自增或自减运算使用+=或-=</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.05.html"><strong aria-hidden="true">3.5.5.</strong> G.EXP.05 使用括号来清楚表示表达式的计算顺序</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/expr/G.EXP.06.html"><strong aria-hidden="true">3.5.6.</strong> G.EXP.06 避免在比较中添加无用的掩码操作</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow.html"><strong aria-hidden="true">3.6.</strong> Control Flow</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/P.CTF.01.html"><strong aria-hidden="true">3.6.1.</strong> P.CTF.01 避免滥用迭代器</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/P.CTF.02.html"><strong aria-hidden="true">3.6.2.</strong> P.CTF.02 优先使用模式匹配而非判断后再取值</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.01.html"><strong aria-hidden="true">3.6.3.</strong> G.CTF.01 当需要通过多个if判断来比较大小来区分不同情况时，优先使用match和cmp来代替if表达式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.02.html"><strong aria-hidden="true">3.6.4.</strong> G.CTF.02 if条件表达式分支中如果包含了else if分支也应该包含else分支</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.03.html"><strong aria-hidden="true">3.6.5.</strong> G.CTF.03 如果要通过 if 条件表达式来判断是否 Panic，请优先使用断言</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/control-flow/G.CTF.04.html"><strong aria-hidden="true">3.6.6.</strong> G.CTF.04 在 Match 分支的 Guard 语句中不要使用带有副作用的条件表达式</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings.html"><strong aria-hidden="true">3.7.</strong> String</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.01.html"><strong aria-hidden="true">3.7.1.</strong> P.STR.01 处理字符串元素时优先按字节处理而非字符</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.02.html"><strong aria-hidden="true">3.7.2.</strong> P.STR.02 创建字符串时，宜预先分配大约足够的容量来避免后续操作中产生多次分配</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.03.html"><strong aria-hidden="true">3.7.3.</strong> P.STR.03 在使用内建字符串处理函数或方法的时候，应注意避免隐藏的嵌套迭代或多次迭代</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.04.html"><strong aria-hidden="true">3.7.4.</strong> P.STR.04 只在合适的场景下，使用正则表达式第三方库regex</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/P.STR.05.html"><strong aria-hidden="true">3.7.5.</strong> P.STR.05 在拼接字符串时，优先使用format!</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.01.html"><strong aria-hidden="true">3.7.6.</strong> G.STR.01 在实现Display特质时不应调用to_string()方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.02.html"><strong aria-hidden="true">3.7.7.</strong> G.STR.02 在追加字符串时使用push_str方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.03.html"><strong aria-hidden="true">3.7.8.</strong> G.STR.03 将只包含 ASCII字符的字符串字面量转为字节序列可以直接使用b&quot;str&quot; 语法代替调用as_bytes方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.04.html"><strong aria-hidden="true">3.7.9.</strong> G.STR.04 需要辨别字符串的字符开头或结尾字符时，不应按字符迭代比较</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/strings/G.STR.05.html"><strong aria-hidden="true">3.7.10.</strong> G.STR.05 对字符串按指定位置进行切片的时候需要小心破坏其 UTF-8 编码</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/collections.html"><strong aria-hidden="true">3.8.</strong> Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/collections/P.CLT.01.html"><strong aria-hidden="true">3.8.1.</strong> P.CLT.01 创建HashMap、VecDeque时，可以预先分配大约足够的容量来避免后续操作中产生多次分配</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/collections/G.CLT.01.html"><strong aria-hidden="true">3.8.2.</strong> G.CLT.01 非必要情况下，不要使用LinkedList，而用Vec或VecDeque代替</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design.html"><strong aria-hidden="true">3.9.</strong> Function Design</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/P.FUD.01.html"><strong aria-hidden="true">3.9.1.</strong> P.FUD.01 Should rebind variables which pass into closure</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/P.FUD.02.html"><strong aria-hidden="true">3.9.2.</strong> P.FUD.02 Don't Use return for return value</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.01.html"><strong aria-hidden="true">3.9.3.</strong> G.FUD.01 Less than 5 function parameters</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.02.html"><strong aria-hidden="true">3.9.4.</strong> G.FUD.02 Should input as reference if parameter derives Copy and its value inputed by-value is a big number</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.03.html"><strong aria-hidden="true">3.9.5.</strong> G.FUD.03 Should refactor into customized struct or enum if there are too many bool type's function parameters</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.04.html"><strong aria-hidden="true">3.9.6.</strong> G.FUD.04 Should input by-value but by-ref if parameter derived Copy, and its value is a small enough number</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.05.html"><strong aria-hidden="true">3.9.7.</strong> G.FUD.05 Don't always specify inline(always) for function</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/fn-design/G.FUD.06.html"><strong aria-hidden="true">3.9.8.</strong> G.FUD.06 Parameters Should be compatible with multiple types</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic.html"><strong aria-hidden="true">3.10.</strong> Generic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.01.html"><strong aria-hidden="true">3.10.1.</strong> P.GEN.01 用泛型来抽象公共语义</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.02.html"><strong aria-hidden="true">3.10.2.</strong> P.GEN.02 不要随便使用 impl Trait 语法替代泛型限定</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.03.html"><strong aria-hidden="true">3.10.3.</strong> P.GEN.03 不要使用太多泛型参数和 trait 限定，否则会增长编译时间</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.04.html"><strong aria-hidden="true">3.10.4.</strong> P.GEN.04 为泛型类型实现方法时，impl 中声明的泛型类型参数一定要被用到</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/P.GEN.05.html"><strong aria-hidden="true">3.10.5.</strong> P.GEN.05 定义泛型函数时，如果该函数实现用到来自 trait 定义的相关行为，需要为泛型指定相关 trait 的限定</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/G.GEN.01.html"><strong aria-hidden="true">3.10.6.</strong> G.GEN.01 不要在泛型位置上使用内建类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/generic/G.GEN.02.html"><strong aria-hidden="true">3.10.7.</strong> G.GEN.02 使用 Rust 标准库中某些方法，要注意避免使用其泛型默认实现，而应该使用具体类型的实现</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits.html"><strong aria-hidden="true">3.11.</strong> Trait</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/P.TRA.01.html"><strong aria-hidden="true">3.11.1.</strong> P.TRA.01 使用 trait 时要注意 trait 一致性规则</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin.html"><strong aria-hidden="true">3.11.2.</strong> 标准库内置 trait</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/P.TRA.BLN.01.html"><strong aria-hidden="true">3.11.2.1.</strong> P.TRA.BLN.01 在实现Borrow特质时，需要注意一致性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.01.html"><strong aria-hidden="true">3.11.2.2.</strong> G.TRA.BLN.01 应该具体类型的 default() 方法代替 Default::default() 调用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.02.html"><strong aria-hidden="true">3.11.2.3.</strong> G.TRA.BLN.02 不要为迭代器实现Copy 特质</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.03.html"><strong aria-hidden="true">3.11.2.4.</strong> G.TRA.BLN.03 能使用派生宏（Derive）自动实现Default特质就不要用手工实现</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.04.html"><strong aria-hidden="true">3.11.2.5.</strong> G.TRA.BLN.04 在使用#[derive(Hash)] 的时候，避免再手工实现 PartialEq</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.05.html"><strong aria-hidden="true">3.11.2.6.</strong> G.TRA.BLN.05 在使用#[derive(Ord)] 的时候，避免再手工实现 PartialOrd</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.06.html"><strong aria-hidden="true">3.11.2.7.</strong> G.TRA.BLN.06 不要对实现 Copy 或引用类型调用 std::mem::drop 和 std::mem::forgot</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.07.html"><strong aria-hidden="true">3.11.2.8.</strong> G.TRA.BLN.07 对实现 Copy 的可迭代类型来说，要通过迭代器拷贝其所有元素时，应该使用 copied方法，而非cloned</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.08.html"><strong aria-hidden="true">3.11.2.9.</strong> G.TRA.BLN.08 实现 From 而不是 Into</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.09.html"><strong aria-hidden="true">3.11.2.10.</strong> G.TRA.BLN.09 一般情况下不要给 Copy 类型手工实现 Clone</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/std-builtin/G.TRA.BLN.10.html"><strong aria-hidden="true">3.11.2.11.</strong> G.TRA.BLN.10 不要随便使用Deref特质来模拟继承</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object.html"><strong aria-hidden="true">3.11.3.</strong> trait 对象</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object/P.TRA.OBJ.01.html"><strong aria-hidden="true">3.11.3.1.</strong> P.TRA.OBJ.01 根据场景合理选择使用trait对象或泛型静态分发</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/traits/trait-object/P.TRA.OBJ.02.html"><strong aria-hidden="true">3.11.3.2.</strong> P.TRA.OBJ.02 除非必要，避免自定义虚表</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle.html"><strong aria-hidden="true">3.12.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/P.ERR.01.html"><strong aria-hidden="true">3.12.1.</strong> P.ERR.01 当传入函数的参数值因为超出某种限制可能会导致函数调用失败，应该使用断言</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/P.ERR.02.html"><strong aria-hidden="true">3.12.2.</strong> P.ERR.02 在确定 Option 和 Result&lt;T, E&gt;类型的值不可能是 None 或 Err 时，请用 expect 代替 unwrap()</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/G.ERR.01.html"><strong aria-hidden="true">3.12.3.</strong> G.ERR.01 在处理 Option 和 Result&lt;T, E&gt; 类型时，不要随便使用 unwrap</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/error-handle/G.ERR.02.html"><strong aria-hidden="true">3.12.4.</strong> G.ERR.02 不要滥用 expect，请考虑用 unwrap_or_ 系列方法代替</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory.html"><strong aria-hidden="true">3.13.</strong> Memory Management</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime.html"><strong aria-hidden="true">3.13.1.</strong> 生命周期</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime/P.MEM.LFT.01.html"><strong aria-hidden="true">3.13.1.1.</strong> P.MEM.LFT.01 生命周期参数命名尽量有意义且简洁</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/lifetime/P.MEM.LFT.02.html"><strong aria-hidden="true">3.13.1.2.</strong> P.MEM.LFT.02 通常需要显式地标注生命周期，而非利用编译器推断</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/smart-ptr.html"><strong aria-hidden="true">3.13.2.</strong> 智能指针</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/smart-ptr/P.MEM.SPT.01.html"><strong aria-hidden="true">3.13.2.1.</strong> P.MEM.SPT.01 使用 RefCell&lt;T&gt; 时宜使用 try_borrow/try_borrow_mut 方法</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box.html"><strong aria-hidden="true">3.13.3.</strong> Box 类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box/G.MEM.BOX.01.html"><strong aria-hidden="true">3.13.3.1.</strong> G.MEM.BOX.01 一般情况下，不应直接对 Box&lt;T&gt; 进行借用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box/G.MEM.BOX.02.html"><strong aria-hidden="true">3.13.3.2.</strong> G.MEM.BOX.02 一般情况下，不应直接对已经在堆上分配内存的类型进行 Box 装箱</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/box/G.MEM.BOX.03.html"><strong aria-hidden="true">3.13.3.3.</strong> G.MEM.BOX.03 一般情况下，不应直接对栈分配类型进行 Box 装箱</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/memory/drop.html"><strong aria-hidden="true">3.13.4.</strong> Drop 析构</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/memory/drop/G.MEM.DRP.01.html"><strong aria-hidden="true">3.13.4.1.</strong> G.MEM.DRP.01 要注意防范内存泄漏</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/module.html"><strong aria-hidden="true">3.14.</strong> Module</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/module/P.MOD.01.html"><strong aria-hidden="true">3.14.1.</strong> P.MOD.01 合理控制对外接口和模块之间的可见性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/P.MOD.02.html"><strong aria-hidden="true">3.14.2.</strong> P.MOD.02 将模块的测试移动到单独的文件，有助于增加编译速度</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.01.html"><strong aria-hidden="true">3.14.3.</strong> G.MOD.01 使用导入模块中的类型或函数，在某些情况下需要带模块名前缀</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.02.html"><strong aria-hidden="true">3.14.4.</strong> G.MOD.02 如果是作为库供别人使用，在 lib.rs中重新导出对外类型、函数和 trait 等</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.03.html"><strong aria-hidden="true">3.14.5.</strong> G.MOD.03 导入模块不要随便使用 通配符*</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.04.html"><strong aria-hidden="true">3.14.6.</strong> G.MOD.04 一个项目中应该避免使用不同的模块布局风格</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/module/G.MOD.05.html"><strong aria-hidden="true">3.14.7.</strong> G.MOD.05 不要在私有模块中设置其内部类型或函数方法为 pub(crate)</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo.html"><strong aria-hidden="true">3.15.</strong> Package Management</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.01.html"><strong aria-hidden="true">3.15.1.</strong> P.CAR.01 应该尽量把项目划分为合理的 crate 组合</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.02.html"><strong aria-hidden="true">3.15.2.</strong> P.CAR.02 不要滥用 Features</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.03.html"><strong aria-hidden="true">3.15.3.</strong> P.CAR.03 使用 cargo features 来代替 --cfg 条件编译参数</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/P.CAR.04.html"><strong aria-hidden="true">3.15.4.</strong> P.CAR.04 如果可能的话，使用 cfg! 来代替 #[cfg]</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.01.html"><strong aria-hidden="true">3.15.5.</strong> G.CAR.01 当项目是可执行程序而非库时，建议使用 src/main.rs 和 src/lib.rs 模式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.02.html"><strong aria-hidden="true">3.15.6.</strong> G.CAR.02 Crate 的 Cargo.toml 中应该包含必要的元信息</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.03.html"><strong aria-hidden="true">3.15.7.</strong> G.CAR.03 Feature 命名应该避免否定式或多余的前后缀</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/cargo/G.CAR.04.html"><strong aria-hidden="true">3.15.8.</strong> G.CAR.04 Cargo.toml 中依赖包版本不应使用通配符</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros.html"><strong aria-hidden="true">3.16.</strong> Macro</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/P.MAC.01.html"><strong aria-hidden="true">3.16.1.</strong> P.MAC.01 不要轻易使用宏</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/P.MAC.02.html"><strong aria-hidden="true">3.16.2.</strong> P.MAC.02 实现宏语法的时候，应该尽量贴近 Rust 语法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/G.MAC.01.html"><strong aria-hidden="true">3.16.3.</strong> G.MAC.01 dbg!() 宏只应该用于调试代码</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/G.MAC.02.html"><strong aria-hidden="true">3.16.4.</strong> G.MAC.02 使用宏时应该考虑宏展开会让编译文件膨胀的影响</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl.html"><strong aria-hidden="true">3.16.5.</strong> Declarative Macro</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.01.html"><strong aria-hidden="true">3.16.5.1.</strong> P.MAC.DCL.01 不要将声明宏内的变量作为外部变量使用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.02.html"><strong aria-hidden="true">3.16.5.2.</strong> P.MAC.DCL.02 在编写多个宏规则时，应该先从匹配粒度最小的开始写</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.03.html"><strong aria-hidden="true">3.16.5.3.</strong> P.MAC.DCL.03 不要在片段分类符跟随它不匹配的符号</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.04.html"><strong aria-hidden="true">3.16.5.4.</strong> P.MAC.DCL.04 匹配规则要精准，不要模糊不清</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.05.html"><strong aria-hidden="true">3.16.5.5.</strong> P.MAC.DCL.05 使用宏替换（substitution）元变量的时候要注意选择合适的片段分类符</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.06.html"><strong aria-hidden="true">3.16.5.6.</strong> P.MAC.DCL.06 当宏需要接收 self 时需要注意</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.07.html"><strong aria-hidden="true">3.16.5.7.</strong> P.MAC.DCL.07 确保在宏定义之后再去调用宏</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/decl/P.MAC.DCL.08.html"><strong aria-hidden="true">3.16.5.8.</strong> P.MAC.DCL.08 同一个 crate 内定义的宏相互调用时，需要注意卫生性</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc.html"><strong aria-hidden="true">3.16.6.</strong> Procedural Macro</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.01.html"><strong aria-hidden="true">3.16.6.1.</strong> P.MAC.PRO.01 不要使用过程宏来规避静态分析检查</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.02.html"><strong aria-hidden="true">3.16.6.2.</strong> P.MAC.PRO.02 实现过程宏时要对关键特性增加测试</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.03.html"><strong aria-hidden="true">3.16.6.3.</strong> P.MAC.PRO.03 保证过程宏的卫生性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.04.html"><strong aria-hidden="true">3.16.6.4.</strong> P.MAC.PRO.04 给出正确的错误位置</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.05.html"><strong aria-hidden="true">3.16.6.5.</strong> P.MAC.PRO.05 代码生成要按情况选择使用过程宏还是 build.rs</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/macros/proc/P.MAC.PRO.06.html"><strong aria-hidden="true">3.16.6.6.</strong> P.MAC.PRO.06 build.rs 生成的代码要保证没有任何警告</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads.html"><strong aria-hidden="true">3.17.</strong> Multi Threads</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock.html"><strong aria-hidden="true">3.17.1.</strong> Lock</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/P.MTH.LCK.01.html"><strong aria-hidden="true">3.17.1.1.</strong> P.MTH.LCK.01 多线程下要注意识别锁争用的情况，避免死锁</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.01.html"><strong aria-hidden="true">3.17.1.2.</strong> G.MTH.LCK.01 对布尔或引用并发访问应该使用原子类型而非互斥锁</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.02.html"><strong aria-hidden="true">3.17.1.3.</strong> G.MTH.LCK.02 宜使用 Arc / Arc&lt;[T]&gt; 来代替 Arc / Arc&lt;Vec&gt;</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.03.html"><strong aria-hidden="true">3.17.1.4.</strong> G.MTH.LCK.03 尽量避免直接使用标准库 std::sync 模块中的同步原语，替换为 parking_lot</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock/G.MTH.LCK.04.html"><strong aria-hidden="true">3.17.1.5.</strong> G.MTH.LCK.04 尽量避免直接使用标准库 std::sync::mpsc 模块中的 channel，替换为 crossbeam</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free.html"><strong aria-hidden="true">3.17.2.</strong> Lock Free</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free/P.MTH.LKF.01.html"><strong aria-hidden="true">3.17.2.1.</strong> P.MTH.LKF.01 除非必要，否则建议使用同步锁</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/threads/lock-free/P.MTH.LKF.02.html"><strong aria-hidden="true">3.17.2.2.</strong> P.MTH.LKF.02 使用无锁编程时，需要合理选择内存顺序</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await.html"><strong aria-hidden="true">3.18.</strong> Async</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/P.ASY.01.html"><strong aria-hidden="true">3.18.1.</strong> P.ASY.01 异步编程并不适合所有场景，计算密集型场景应该考虑同步编程</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.01.html"><strong aria-hidden="true">3.18.2.</strong> G.ASY.01 在 async 块或函数中调用 async 函数或闭包请不要忘记添加.await</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.02.html"><strong aria-hidden="true">3.18.3.</strong> G.ASY.02 在跨 await 调用中，需要对其持有的同步互斥锁进行处理</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.03.html"><strong aria-hidden="true">3.18.4.</strong> G.ASY.03 在跨 await 调用中，需要对其持有 RefCell 的引用进行处理</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.04.html"><strong aria-hidden="true">3.18.5.</strong> G.ASY.04 避免定义不必要的异步函数</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/async-await/G.ASY.05.html"><strong aria-hidden="true">3.18.6.</strong> G.ASY.05 避免在异步处理过程中包含阻塞操作</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust.html"><strong aria-hidden="true">3.19.</strong> Unsafe Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/P.UNS.01.html"><strong aria-hidden="true">3.19.1.</strong> P.UNS.01 不要为了逃避编译器安全检查而滥用 Unsafe Rust</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/P.UNS.02.html"><strong aria-hidden="true">3.19.2.</strong> P.UNS.02 不要为了提升性能而盲目使用 Unsafe Rust</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/G.UNS.01.html"><strong aria-hidden="true">3.19.3.</strong> G.UNS.01 不宜为带有 unsafe 命名的类型或方法创建别名</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract.html"><strong aria-hidden="true">3.19.4.</strong> Safety Abstract</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.01.html"><strong aria-hidden="true">3.19.4.1.</strong> P.UNS.SAS.01 代码中要注意是否会因为 Panic 发生而导致内存安全问题</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.02.html"><strong aria-hidden="true">3.19.4.2.</strong> P.UNS.SAS.02 Unsafe 代码编写者有义务检查代码是否满足安全不变式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.03.html"><strong aria-hidden="true">3.19.4.3.</strong> P.UNS.SAS.03 不要随便在公开的 API 中暴露未初始化内存</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.04.html"><strong aria-hidden="true">3.19.4.4.</strong> P.UNS.SAS.04 避免因为 Panic Safety 而导致双重释放</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.05.html"><strong aria-hidden="true">3.19.4.5.</strong> P.UNS.SAS.05 手动实现 auto trait 时要充分考虑其安全性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.06.html"><strong aria-hidden="true">3.19.4.6.</strong> P.UNS.SAS.06 不要随便在公开的 API 中暴露裸指针</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.07.html"><strong aria-hidden="true">3.19.4.7.</strong> P.UNS.SAS.07 在抽象安全方法的同时，也建议为性能考虑而增加相应的 Unsafe 方法</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.08.html"><strong aria-hidden="true">3.19.4.8.</strong> P.UNS.SAS.08 函数参数是不可变借用的时候，返回值不应该是可变借用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/P.UNS.SAS.09.html"><strong aria-hidden="true">3.19.4.9.</strong> P.UNS.SAS.09 在任何 Unsafe 块之前都应该加 SAFETY 注释</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.01.html"><strong aria-hidden="true">3.19.4.10.</strong> G.UNS.SAS.01 在公开的 unsafe 函数的文档中必须增加 Safety 注释</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/safe_abstract/G.UNS.SAS.02.html"><strong aria-hidden="true">3.19.4.11.</strong> G.UNS.SAS.02 在 Unafe 函数中应使用 assert! 而非 debug_assert! 去校验边界条件</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr.html"><strong aria-hidden="true">3.19.5.</strong> Modification of Raw Pointer</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/P.UNS.PTR.01.html"><strong aria-hidden="true">3.19.5.1.</strong> P.UNS.PTR.01 不要将裸指针在多线程间共享</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/P.UNS.PTR.02.html"><strong aria-hidden="true">3.19.5.2.</strong> P.UNS.PTR.02 建议使用 NonNull&lt;T&gt; 来替代 *mut T</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/P.UNS.PTR.03.html"><strong aria-hidden="true">3.19.5.3.</strong> P.UNS.PTR.03 使用指针类型构造泛型结构体时，需要使用 PhantomData&lt;T&gt; 来指定 T上的协变和所有权</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.01.html"><strong aria-hidden="true">3.19.5.4.</strong> G.UNS.PTR.01 当指针类型被强转为和当前内存对齐不一致的指针类型时，禁止对其解引用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.02.html"><strong aria-hidden="true">3.19.5.5.</strong> G.UNS.PTR.02 禁止将不可变指针手工转换为可变指针</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/raw_ptr/G.UNS.PTR.03.html"><strong aria-hidden="true">3.19.5.6.</strong> G.UNS.PTR.03 尽量使用 pointer::cast 来代替 使用 as 强转指针</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union.html"><strong aria-hidden="true">3.19.6.</strong> Union</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union/P.UNS.UNI.01.html"><strong aria-hidden="true">3.19.6.1.</strong> P.UNS.UNI.01 除了与 C 交互，尽量不要使用 Union</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/union/P.UNS.UNI.02.html"><strong aria-hidden="true">3.19.6.2.</strong> P.UNS.UNI.02 不要把联合体的不同变体用在不同生命周期内</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem.html"><strong aria-hidden="true">3.19.7.</strong> Memory</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.01.html"><strong aria-hidden="true">3.19.7.1.</strong> P.UNS.MEM.01 要注意选择合适的结构体、元组、枚举的数据布局</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.02.html"><strong aria-hidden="true">3.19.7.2.</strong> P.UNS.MEM.02 不能修改其它进程或动态库的内存变量</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.03.html"><strong aria-hidden="true">3.19.7.3.</strong> P.UNS.MEM.03 不能让 String/Vec 自动 Drop 其它进程或动态库的内存数据</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.04.html"><strong aria-hidden="true">3.19.7.4.</strong> P.UNS.MEM.04 尽量用可重入(reentrant)版本的 C-API 或系统调用</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/P.UNS.MEM.05.html"><strong aria-hidden="true">3.19.7.5.</strong> P.UNS.MEM.05 如果需要使用位域，推荐使用第三方库</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/mem/G.UNS.MEM.01.html"><strong aria-hidden="true">3.19.7.6.</strong> G.UNS.MEM.01 使用 MaybeUninit&lt;T&gt; 来处理未初始化的内存</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi.html"><strong aria-hidden="true">3.19.8.</strong> FFi</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.01.html"><strong aria-hidden="true">3.19.8.1.</strong> P.UNS.FFI.01 避免从公开的 Rust API 直接传字符串到 C 中</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.02.html"><strong aria-hidden="true">3.19.8.2.</strong> P.UNS.FFI.02 在使用标准库 std::ffi 模块提供的类型时需要仔细查看其文档</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.03.html"><strong aria-hidden="true">3.19.8.3.</strong> P.UNS.FFI.03 当使用来自 C 的指针时，如果该指针需要管理内存，则需要为包装该指针的 Rust 类型实现 Drop 特质</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.04.html"><strong aria-hidden="true">3.19.8.4.</strong> P.UNS.FFI.04 如果一个函数正在跨越 FFi 边界，那么需要处理 Panic</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.05.html"><strong aria-hidden="true">3.19.8.5.</strong> P.UNS.FFI.05 建议使用诸如标准库或 libc crate 所提供的可移植类型别名，而不是特定平台的类型</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.06.html"><strong aria-hidden="true">3.19.8.6.</strong> P.UNS.FFI.06 Rust 和 C 之间传递字符或字符串时需要注意字符串要符合 C-ABI 以及 字符串的编码</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.07.html"><strong aria-hidden="true">3.19.8.7.</strong> P.UNS.FFI.07 不要为任何传出外部的类型实现 Drop</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.08.html"><strong aria-hidden="true">3.19.8.8.</strong> P.UNS.FFI.08 FFi 中要进行合理的错误处理</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.09.html"><strong aria-hidden="true">3.19.8.9.</strong> P.UNS.FFI.09 当 Rust 调用外部 C 函数时，如果可以确认安全，可以通过引用来代替裸指针</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.10.html"><strong aria-hidden="true">3.19.8.10.</strong> P.UNS.FFI.10 当 Rust 函数导出外部函数时，必须从设计上保证被跨线程调用的安全性</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.11.html"><strong aria-hidden="true">3.19.8.11.</strong> P.UNS.FFI.11 如需引用指定为 #[repr(packed)] 内存布局的结构体成员字段要注意合理规避未定义行为</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.12.html"><strong aria-hidden="true">3.19.8.12.</strong> P.UNS.FFI.12 当依赖 C 端传入参数时，需要在文档注释中不变性声明，根据不同的调用场景选择合适的安全抽象方式</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.13.html"><strong aria-hidden="true">3.19.8.13.</strong> P.UNS.FFI.13 自定义数据类型要保证一致的数据布局</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.14.html"><strong aria-hidden="true">3.19.8.14.</strong> P.UNS.FFI.14 在 FFi 中使用的类型应该拥有稳定布局</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/ffi/P.UNS.FFI.15.html"><strong aria-hidden="true">3.19.8.15.</strong> P.UNS.FFI.15 从外部传入的不健壮类型的外部值要进行检查</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/io.html"><strong aria-hidden="true">3.19.9.</strong> I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/io/P.UNS.FIO.01.html"><strong aria-hidden="true">3.19.9.1.</strong> P.UNS.FIO.01 在使用原始句柄的时候，要注意 I/O 安全性</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/unsafe_rust/glossary.html"><strong aria-hidden="true">3.19.10.</strong> Unsafe 代码术语指南</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/no-std.html"><strong aria-hidden="true">3.20.</strong> no-std</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/no-std/P.EMB.01.html"><strong aria-hidden="true">3.20.1.</strong> P.EMB.01 no-std 下必须定义一个Panic行为以确保安全</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/no-std/P.EMB.02.html"><strong aria-hidden="true">3.20.2.</strong> P.EMB.02 no-std 下要确保程序中的类型有正确的内存布局</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/io.html"><strong aria-hidden="true">3.21.</strong> I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/io/P.FIO.01.html"><strong aria-hidden="true">3.21.1.</strong> P.FIO.01 使用 read_to_end/read_to_string方法时注意文件的大小能否一次性读入内存中</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/io/G.FIO.01.html"><strong aria-hidden="true">3.21.2.</strong> G.FIO.01 文件读取建议使用 BufReader/BufWriter 来代替 Reader/Write</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/security.html"><strong aria-hidden="true">3.22.</strong> Information Security</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/security/P.SEC.01.html"><strong aria-hidden="true">3.22.1.</strong> P.SEC.01 使用第三方库的时候要确保可信的依赖，小心供应链攻击</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/security/G.SEC.01.html"><strong aria-hidden="true">3.22.2.</strong> G.SEC.01 代码中不要出现非法 Unicode 字符，也要防范非法 Unicode 字符</a></li></ol></li><li class="chapter-item "><a href="safe-guides/coding_practice/others.html"><strong aria-hidden="true">3.23.</strong> Others</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/coding_practice/others/G.OTH.01.html"><strong aria-hidden="true">3.23.1.</strong> G.OTH.01 对于某些场景下不建议使用的方法可以通过配置 clippy.toml 来拒绝</a></li><li class="chapter-item "><a href="safe-guides/coding_practice/others/G.OTH.02.html"><strong aria-hidden="true">3.23.2.</strong> G.OTH.01 使用标准库中对应的方法计算秒级、毫秒级、微秒级的时间</a></li></ol></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/toc.html"><strong aria-hidden="true">4.</strong> Appendix</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/dev_env.html"><strong aria-hidden="true">4.1.</strong> A.Development Enviroment</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test.html"><strong aria-hidden="true">4.2.</strong> B.Test</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/test/unit_test.html"><strong aria-hidden="true">4.2.1.</strong> Unit Test</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test/benchmark.html"><strong aria-hidden="true">4.2.2.</strong> Benchmark Test</a></li><li class="chapter-item "><a href="safe-guides/Appendix/test/fuzz.html"><strong aria-hidden="true">4.2.3.</strong> Fuzz Test</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/terms.html"><strong aria-hidden="true">4.3.</strong> C.Terminology</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/intro.html"><strong aria-hidden="true">4.4.</strong> D.Templates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/templates/rustfmt.toml.html"><strong aria-hidden="true">4.4.1.</strong> rustfmt</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/clippy.toml.html"><strong aria-hidden="true">4.4.2.</strong> clippy</a></li><li class="chapter-item "><a href="safe-guides/Appendix/templates/deny.toml.html"><strong aria-hidden="true">4.4.3.</strong> deny</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/intro.html"><strong aria-hidden="true">4.5.</strong> E.Toolchains</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/tools/rustfmt.html"><strong aria-hidden="true">4.5.1.</strong> rustfmt</a></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/noisy-clippy.html"><strong aria-hidden="true">4.5.2.</strong> noisy-clippy</a></li><li class="chapter-item "><a href="safe-guides/Appendix/tools/cargo-udeps.html"><strong aria-hidden="true">4.5.3.</strong> cargo-udeps</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/cheat-sheet/index.html"><strong aria-hidden="true">4.6.</strong> F.Cheat Sheet</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/cheat-sheet/Numbers/float.html"><strong aria-hidden="true">4.6.1.</strong> Float</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/optimizing/intro.html"><strong aria-hidden="true">4.7.</strong> G.Guide for Optimizations</a></li><li class="chapter-item "><a href="safe-guides/Appendix/rustc-flag.html"><strong aria-hidden="true">4.8.</strong> H.Rustc Flags</a></li><li class="chapter-item "><a href="safe-guides/Appendix/best-practice/intro.html"><strong aria-hidden="true">4.9.</strong> I.Best Practice</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="safe-guides/Appendix/best-practice/qa.html"><strong aria-hidden="true">4.9.1.</strong> FAQ for Beginners</a></li><li class="chapter-item "><a href="safe-guides/Appendix/best-practice/tips.html"><strong aria-hidden="true">4.9.2.</strong> Rust Programming Techniques</a></li></ol></li><li class="chapter-item "><a href="safe-guides/Appendix/contribution.html"><strong aria-hidden="true">4.10.</strong> J.Contribution Guidlines</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust Coding Specification V1.0 beta</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Rust-Coding-Guidelines/rust-coding-guidelines" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p><a href="https://rust-coding-guidelines.github.io/rust-coding-guidelines-zh/">《Rust 编码规范》 中文版</a></p>
<blockquote>
<p>WIP.See the Chinese version for the full version, the English version is currently being translated from the Chinese version, welcome to participate in the contribution!</p>
</blockquote>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<ul>
<li><a href="./overview/why.html">1.1 Why you need the Rust coding specification ?</a></li>
<li><a href="./overview/convention.html">1.2 Basic conventions of the coding specification</a></li>
</ul>
<h2 id="introduce"><a class="header" href="#introduce">Introduce</a></h2>
<p>It is understood that some companies and organizations within the Rust community maintain their own coding specifications. Some of the publicly available ones are listed below.</p>
<ul>
<li><a href="https://rust-lang.github.io/api-guidelines/about.html">Rust API Guidelines</a></li>
<li><a href="https://github.com/rust-dev-tools/fmt-rfcs/blob/master/guide/guide.md">Rust Style Guide</a></li>
<li><a href="https://rust-lang.github.io/unsafe-code-guidelines/">Rust's Unsafe Code Guidelines Reference</a></li>
<li><a href="https://anssi-fr.github.io/rust-guide">ANSSI | Secure Rust Guidelines</a></li>
<li><a href="https://github.com/pingcap/style-guide">PingCAP | Rust Style Guide</a></li>
<li><a href="https://fuchsia.dev/fuchsia-src/development/languages/rust">Google Fuchsia  OS Rust Guide</a></li>
<li><a href="https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/dev/style.md">RustAnalyzer Style Guide</a></li>
<li><a href="https://rust-lang.github.io/rust-clippy/master/index.html">Clippy lints</a></li>
<li><a href="https://doc.rust-lang.org/rustc/lints/listing/allowed-by-default.html">lints in the rustc book </a></li>
<li><a href="https://github.com/dtolnay/noisy-clippy">Noisy Clippy</a></li>
<li><a href="https://rust-lang.github.io/rustfmt/?version=v1.4.38&amp;search=">Rustfmt Rules</a></li>
</ul>
<h2 id="the-role-of-coding-specifications"><a class="header" href="#the-role-of-coding-specifications">The role of coding specifications</a></h2>
<ol>
<li>Improve the readability, maintainability, robustness, and portability of code by following Rust language features. </li>
<li>Improve the standardization and security of Unsafe Rust code writing. </li>
<li>The programming specification terms strive to systematize, easy to apply, easy to check, to help developers improve development efficiency.</li>
<li>Give developers a clear and global vision, in the process of developing code can follow a good code specification, rather than wait until the code is written and then through <code>rustfmt</code> and <code>clippy</code> such tools, a line to modify the warning.</li>
<li>The specification is not a tutorial, but the level of developers varies. For some knowledge blind spots and those that may lead to program errors, the specification will also cover.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-why-you-need-the-rust-coding-specification-"><a class="header" href="#11-why-you-need-the-rust-coding-specification-">1.1 Why you need the Rust coding specification ?</a></h1>
<p>When I first learned Rust, I marveled at the sophistication of the tools Rust provides. For example, <code>rustfmt</code>, which automatically formats code, and <code>clippy</code>, which helps you standardize code that is not written properly. They are truly excellent tools. At the time, I didn't think Rust needed to be coded at all like other languages.</p>
<p>But as I learned more and more about Rust, I came to realize that these tools had a lot of shortcomings and did not cover everything. For example, improper configuration and use of rustfmt can lead to code errors and inability to recognize the semantics of various naming in Rust code; clippy has some false positives or lint is not reasonable, and can not cover to Unsafe Rust and other issues. Developers, especially newcomers, if they rely on <code>rutfmt</code> and <code>clippy</code> for a long time like using a black box, but do not understand the reason behind their lint, just know the reason but not the reason. it is impossible to improve the development efficiency under the premise that the code quality has certain requirements.</p>
<p>So, <code>rutfmt</code> and <code>clippy</code> are not a panacea. We also need a comprehensive and universal coding specification that also covers tools like <code>rustfmt</code> and <code>clippy</code>, so that the majority of Rust teams can quickly implement Rust and enhance collaboration and trust between teams by standardizing the principles and rules to understand the basic framework for writing authentic Rust code.</p>
<h2 id="limitations-of-rustfmt-and-clippy"><a class="header" href="#limitations-of-rustfmt-and-clippy">Limitations of Rustfmt and Clippy</a></h2>
<h3 id="limitations-of-rustfmt"><a class="header" href="#limitations-of-rustfmt">Limitations of Rustfmt</a></h3>
<p>Rust has an automatic formatting tool, rustfmt, which helps developers get rid of the manual work of formatting code and increase productivity. However, it does not replace the coding specification to standardize the coding style of Rust code.</p>
<p>The main drawbacks of rustfmt are the following.</p>
<ol>
<li>The naming of variables, types, functions, etc. in Rust contains semantics, especially ownership semantics. rustfmt tool cannot determine the naming semantics in the code. This aspect can be partially satisfied by using Clippy, but it is rather one-sided for developers.</li>
<li>rustfmt can cause problems if used improperly or configured improperly. Because rustfmt is an auto-formatting tool, it automatically modifies the code, but it does not compile when it modifies the code. If the developer configures autosave and then executes rustfmt automatically, it will cause the code to be modified incorrectly. Or, there are some configuration options for rustfmt that are misconfigured, which will also cause the code to be modified incorrectly.</li>
<li>The configuration items of rustfmt tool are fragmented, and most developers do not understand the meaning of each configuration item.</li>
<li>rustfmt does not have a coding specification that covers code comments and documentation comments.</li>
</ol>
<p>In summary, there is a particular need to provide a common coding specification so that developers clearly understand what coding style Rust follows overall in terms of naming, formatting and commenting. It will cover the content of rustfmt, but not mechanically extract the rules of rustfmt one by one, but a unified categorization and organization of the rules of rustfmt, to facilitate developers to understand the rules set in rustfmt, and to facilitate the team to form their own code style.</p>
<h3 id="clippys-limitations"><a class="header" href="#clippys-limitations">Clippy's limitations</a></h3>
<p>Clippy is a linter for Rust, one of the main components of the Rust ecosystem. It performs additional static checks on developed code, reports problems found and explains how to fix them (sometimes it can even fix them automatically). Using it can be beneficial for Rust beginners and even professionals.</p>
<p>However, using Clippy does not mean that it can replace coding specifications, and it has many drawbacks: </p>
<ol>
<li>Unsafe Rust is a very important part of Rust and needs to be covered by a complete coding specification to help developers write safe Unsafe code.</li>
<li>there are more than 500 lint in Clippy so far, and there is a growing trend. it is impossible for developers to understand each lint one by one, so a coding specification is needed to help developers to sort out and categorize lint.</li>
<li>there is some controversy about the suggestion and classification (allow/warning/deny) of lint in Clippy. Some lint is allow by default, but it does not mean that it is reasonable to write in some scenarios; similarly, some lint is warning, but it does not mean that it is unreasonable in some scenarios. For this reason, dtolnay also created this repository: <a href="https://github.com/dtolnay/noisy-clippy">https://github.com/dtolnay/noisy-clippy</a> for analyzing how many Clippy lint's in the community crate suggestions does not match the actual scenario, so as to achieve the goal of improving Clippy.</li>
</ol>
<p>In summary, Clippy is a very useful tool, but it is not a replacement for coding specifications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-basic-conventions-of-the-coding-specification"><a class="header" href="#12-basic-conventions-of-the-coding-specification">1.2 Basic conventions of the coding specification</a></h1>
<p><strong>Programming specifications are in no way written to increase the burden on developers and are intended to help developers write high-quality Rust code.</strong></p>
<p>To accomplish this, the specification terms are divided into two categories: <strong>Principles</strong> and <strong>Rules</strong>.</p>
<ul>
<li>
<p>A principle is a general direction that guides programming development, or refers to a class of situations. There are also a few principles that are detectable by the Rust compiler, but because the compiler diagnostic information is confusing, principles are added to help developers avoid such situations.</p>
</li>
<li>
<p>Rules, as opposed to principles, are more specific and contain positive and negative examples to further illustrate them. Some rules also add exceptions. The rules are basically detectable by lint.</p>
</li>
</ul>
<h2 id="rule-content-relationship-with-rustfmt-and-clippy"><a class="header" href="#rule-content-relationship-with-rustfmt-and-clippy">Rule content Relationship with rustfmt and clippy</a></h2>
<p>The specification is divided into two main parts: code style and code practice.</p>
<p><strong>Code style</strong></p>
<p>Code naming, formatting and comments are included in the code style.</p>
<ul>
<li>The naming part, mainly by clippy lint to check, some naming rules clippy lint does not provide detection, then need to custom lint to support.</li>
<li>The format part, mainly using rustfmt to automatically modify, the rules in the coding specification describes most of the configuration items of rustfmt by category, in order to facilitate developers to make reference and develop their own configuration items. Configuration templates are also provided in the coding specification.</li>
<li>The comments section, which includes general comments and documentation comments, rule entries are regulated through a collaboration between rustfmt and clippy.</li>
</ul>
<p><strong>Code Practices</strong></p>
<p>The code practices are categorized by Rust language features, and each language feature is summarized as much as possible for everyday coding best practices, extracted into a list of principles and rules for developers to refer to. Most of the rules are recommendations, and the rules that are required are basically security-related.</p>
<p>Clippy lint involves a lot of skillful lint, so it is not put into the specification.</p>
<p>The <strong>rules mainly focus on generic scenarios, code readability, maintainability, security, performance of the four considerations, it only covers a small part (less than 1/5) clippy lint</strong>. There are also rules that are not available in the clippy lint and require custom lint.</p>
<p>The focus of the code practice content is on the Unsafe Rust coding specification, which has more coding principles than rules, and which is rarely detected by Clippy lint. There are more rules that require classes.</p>
<p>We hope that this section will help developers avoid some common pitfalls in writing Rust code.</p>
<h2 id="coding-specification-content-conventions"><a class="header" href="#coding-specification-content-conventions">Coding specification content conventions</a></h2>
<p>Identified by the number before the title.</p>
<ul>
<li>Identified as <code>P</code> for Principle. Numbered as <code>P.Element.Number</code>.</li>
<li>Identified as <code>G</code> for Rule (Guideline). The numbering is <code>G.Element.Number</code>.</li>
<li>When there are subdirectories. Number is <code>P.Element.SubElement.Number</code> or <code>G.Element.SubElement.Number</code>.</li>
</ul>
<p>Number is incremented from <code>01</code>. Where <code>Element</code> is the three-letter abbreviation for the key element (corresponding to the secondary catalog in this specification) in the domain knowledge. (Terminology reference: <a href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard">SEI CERT C Coding Standard</a>)</p>
<table><thead><tr><th>Element</th><th>Explanation</th><th>Element</th><th>Explanation</th></tr></thead><tbody>
<tr><td>NAM</td><td>命名 (Naming)</td><td>CMT</td><td>注释 (Comment)</td></tr>
<tr><td>FMT</td><td>格式 (Format)</td><td>TYP</td><td>数据类型 (Data Type)</td></tr>
<tr><td>CNS</td><td>常量 (Const)</td><td>VAR</td><td>变量  (Variables)</td></tr>
<tr><td>EXP</td><td>表达式 (Expression)</td><td>CTF</td><td>控制流程 (Control Flow)</td></tr>
<tr><td>REF</td><td>引用 (Reference)</td><td>PTR</td><td>指针  (Pointer)</td></tr>
<tr><td>STR</td><td>字符串 (String)</td><td>INT</td><td>整数 (Integer)</td></tr>
<tr><td>MOD</td><td>模块  (Module)</td><td>CAR</td><td>包管理  (Cargo)</td></tr>
<tr><td>MEM</td><td>内存 (Memory)</td><td>FUD</td><td>函数设计 (Function Design)</td></tr>
<tr><td>MAC</td><td>宏  (Macro)</td><td>STV</td><td>静态变量 (Static Variables)</td></tr>
<tr><td>GEN</td><td>泛型 (Generic)</td><td>TRA</td><td>特质 (Trait)</td></tr>
<tr><td>ASY</td><td>异步 (Async)</td><td>UNS</td><td>非安全 (Unsafe Rust)</td></tr>
<tr><td>SAS</td><td>安全抽象 (Safety Abstract)</td><td>FFI</td><td>外部函数调用接口 ( Foreign Function Interface )</td></tr>
<tr><td>LAY</td><td>内存布局 (Layout)</td><td>ERR</td><td>错误处理 (Error Handle)</td></tr>
<tr><td>CLT</td><td>集合  (Collection)</td><td>MTH</td><td>多线程 (Multi Threads)</td></tr>
<tr><td>EMB</td><td>嵌入式Rust (Embedded Rust)</td><td>FIO</td><td>输入输出 (In/Out)</td></tr>
<tr><td>SEC</td><td>信息安全 (Security)</td><td>SPT</td><td>智能指针 (Smart Pointer)</td></tr>
<tr><td>UNT</td><td>单元类型 (Unit)</td><td>BOL</td><td>布尔 (Bool)</td></tr>
<tr><td>CHR</td><td>字符类型 (Char)</td><td>FLT</td><td>浮点数 (Float)</td></tr>
<tr><td>SLC</td><td>切片类型 (Slice)</td><td>TUP</td><td>元组 (Tuple)</td></tr>
<tr><td>ARR</td><td>固定长度数组类型 (Array)</td><td>VEC</td><td>动态长度数组 (Vector)</td></tr>
<tr><td>SCT</td><td>结构体 (Struct)</td><td>ENM</td><td>枚举体 (Enum)</td></tr>
<tr><td>UNI</td><td>联合体 (Union)</td><td>BLN</td><td>标准库内置（BuiltIn）</td></tr>
<tr><td>OBJ</td><td>Trait 对象 (Trait Object)</td><td>LFT</td><td>生命周期 (Lifetime)</td></tr>
<tr><td>BOX</td><td><code>Box&lt;T&gt;</code> 类型</td><td>DRP</td><td>析构函数 (Drop)</td></tr>
<tr><td>DCL</td><td>声明宏 (Declarative)</td><td>PRO</td><td>过程宏 (Procedural)</td></tr>
<tr><td>LCK</td><td>锁同步 (Lock)</td><td>LKF</td><td>无锁 (Lock Free)</td></tr>
<tr><td></td><td></td><td>OTH</td><td>其他 (Ohters)</td></tr>
</tbody></table>
<h2 id="reference-code-open-source-license-description"><a class="header" href="#reference-code-open-source-license-description">Reference code open source license description</a></h2>
<p>All references to external code in this specification meet the <code>MIT/Apache/Mozilla public licenses</code> open source license!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="代码风格"><a class="header" href="#代码风格">代码风格</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-naming"><a class="header" href="#21-naming">2.1 Naming</a></h1>
<p>A good naming style allows us to quickly understand what a name represents (type, variable, function, constant, macro, etc.) and even highlights its semantics in the overall code context. Naming management is quite important to improve the readability and maintainability of your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pnam01-同一个crate中标识符的命名规则应该使用统一的词序"><a class="header" href="#pnam01-同一个crate中标识符的命名规则应该使用统一的词序">P.NAM.01 同一个crate中标识符的命名规则应该使用统一的词序</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pnam02-为-cargo-feature-命名时不应含有无意义的占位词"><a class="header" href="#pnam02-为-cargo-feature-命名时不应含有无意义的占位词">P.NAM.02 为 cargo feature 命名时不应含有无意义的占位词</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pnam03-标识符命名应该符合阅读习惯"><a class="header" href="#pnam03-标识符命名应该符合阅读习惯">P.NAM.03 标识符命名应该符合阅读习惯</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pnam04-作用域越大命名越精确反之应简短"><a class="header" href="#pnam04-作用域越大命名越精确反之应简短">P.NAM.04 作用域越大命名越精确，反之应简短</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="pnam05-the-getter-family-of-methods-used-to-access-or-retrieve-data-should-not-normally-have-the-prefix-get_"><a class="header" href="#pnam05-the-getter-family-of-methods-used-to-access-or-retrieve-data-should-not-normally-have-the-prefix-get_">P.NAM.05 The <code>getter</code> family of methods used to access or retrieve data should not normally have the prefix <code>get_</code></a></h2>
<p><strong>[Description]</strong></p>
<p>Because of Rust's ownership semantics, both methods' parameters in following cases use shared reference <code>&amp;self</code> or exclusive reference <code>&amp;mut self</code> , which represent <code>getter</code> semantics.</p>
<blockquote>
<p><code>getter</code> semantics always mean to return an object but a reference in Rust's ownership conventions.</p>
</blockquote>
<p>There are also some exceptions to use <code>get_</code> prefix.</p>
<p><strong>[Bad Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct First;
pub struct Second;

pub struct S {
    first: First,
    second: Second,
}

impl S {
    // Bad: Shouldn't use 'get_' prefix to name accesssing member function.
    pub fn get_first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // Bad：
    // `get_mut_first`, or `mut_first` are also not good.
    pub fn get_first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }

    // set_ prefix is fine.
    pub fn set_first(&amp;mut self, f: First) -&gt; &amp;mut First {
        self.first = f;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Good Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct First;
pub struct Second;

pub struct S {
    first: First,
    second: Second,
}

impl S {
    // Ok
    pub fn first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // Ok
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }

    // set_ prefix is fine.
    pub fn set_first(&amp;mut self, f: First) -&gt; &amp;mut First {
        self.first = f;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Exception]</strong></p>
<p>However, there are also some exceptions: Only in cases to retrieve data by <code>getter</code> explicitly, could name with <code>get_</code> prefix. For example, <code>Cell::get</code> could access the data in one <code>Cell</code>.</p>
<p>For <code>getter</code> checked in runtime, such as bounds checking, we could consider to add an Unsafe <code>_unchecked</code> methods. Generally, there would be following function signatures.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Do some checks in runtime, such as bounds checking.
fn get(&amp;self, index: K) -&gt; Option&lt;&amp;V&gt;;
fn get_mut(&amp;mut self, index: K) -&gt; Option&lt;&amp;mut V&gt;;
// No runtime checking, use to improve performance in some case. 
// For examplem, when executed in an execution environment,which is impossible to trigger bounds checking.
unsafe fn get_unchecked(&amp;self, index: K) -&gt; &amp;V;
unsafe fn get_unchecked_mut(&amp;mut self, index: K) -&gt; &amp;mut V;
<span class="boring">}
</span></code></pre></pre>
<p>There is almost no such distinction between <code>getter</code> and type conversion (<a href="safe-guides/code_style/naming/./G.NAM.02.html">G.NAM.02</a>). For instance, <a href="https://docs.rs/tempdir/0.3.7/tempdir/struct.TempDir.html#method.path"><code>TemDir::path</code></a> could be regarded as a <code>getter</code>, which represents the filesystem's path of temporary directory, and <a href="https://docs.rs/tempdir/0.3.7/tempdir/struct.TempDir.html#method.into_path"><code>TemDir::into_path</code></a> is in charge of sending converted data when deleting temporary directory
to callee.</p>
<p>There would not result for redundancy with naming the method as <code>path</code>, because <code>path</code> itself is a <code>getter</code>, otherwise if you name it as <code>get_path</code> or <code>as_path</code>.</p>
<p>Implementations in <code>StandardLibrary</code>:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut"><code>std::io::Cursor::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut"><code>std::ptr::Unique::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut"><code>std::sync::PoisonError::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>&lt;[T]&gt;::get_unchecked</code></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pnam06-遵循-iter-iter_mut-into_iter-规范来生成迭代器"><a class="header" href="#pnam06-遵循-iter-iter_mut-into_iter-规范来生成迭代器">P.NAM.06 遵循 iter/ iter_mut/ into_iter 规范来生成迭代器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pnam07-避免使用语言内置保留字关键字内置类型和trait等特殊名称"><a class="header" href="#pnam07-避免使用语言内置保留字关键字内置类型和trait等特殊名称">P.NAM.07 避免使用语言内置保留字、关键字、内置类型和trait等特殊名称</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pnam08-避免在变量的命名中添加类型标识"><a class="header" href="#pnam08-避免在变量的命名中添加类型标识">P.NAM.08 避免在变量的命名中添加类型标识</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pnam09-定义全局静态变量时需加前缀g_以便和常量有所区分"><a class="header" href="#pnam09-定义全局静态变量时需加前缀g_以便和常量有所区分">P.NAM.09 定义全局静态变量时需加前缀G_以便和常量有所区分</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gnam01-use-a-uniform-naming-style"><a class="header" href="#gnam01-use-a-uniform-naming-style">G.NAM.01 Use a uniform naming style</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gnam02-类型转换函数命名需要遵循所有权语义"><a class="header" href="#gnam02-类型转换函数命名需要遵循所有权语义">G.NAM.02 类型转换函数命名需要遵循所有权语义</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-format"><a class="header" href="#22-format">2.2 Format</a></h1>
<p>A uniform coding style is developed to improve the readability of code and make it easier to maintain daily code and review code between teams.</p>
<p>Rust has an automated formatting tool, rustfmt, to help developers get rid of the manual work of formatting code and improve productivity. However, what style specification rustfmt follows, as developers need to understand, when writing code can be proactively written in such a style.</p>
<p><strong>Description</strong>:</p>
<p>For unstable configuration items in <code>rustfmt</code> (<code>Stable</code> is <code>No</code>), it means that the configuration item cannot be changed in the stable (Stable) version of Rust, but its default value will take effect when <code>cargo fmt</code>. Under Nightly Rust, all configurations can be customized.</p>
<p>For information on how to use unstable configuration items in Stable Rust, sample configurations, and other global configuration item descriptions, see: <a href="safe-guides/code_style/./../Appendix/tools/rustfmt.html">Rustfmt Configuration Description</a>.</p>
<p><strong>Caution</strong></p>
<p>Because the rustfmt tool automatically modifies code, to ensure that rustfmt does not accidentally change the wrong code, you should pay attention to the following two descriptions when using rustfmt: 1.</p>
<ol>
<li>
<p>Always make sure that the rustfmt command is executed after all the code has been modified and compiled. Because the code is not compiled during rustfmt execution, there is no static check protection. 2.</p>
</li>
<li>
<p>If you are using an IDE or editor with automatic protection turned on, do not turn on automatic rustfmt execution.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt01-使用-rustfmt-进行自动格式化代码"><a class="header" href="#pfmt01-使用-rustfmt-进行自动格式化代码">P.FMT.01 使用 rustfmt 进行自动格式化代码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt02-缩进使用空格而非制表符"><a class="header" href="#pfmt02-缩进使用空格而非制表符">P.FMT.02 缩进使用空格而非制表符</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt03-行间距最大宽度空一行"><a class="header" href="#pfmt03-行间距最大宽度空一行">P.FMT.03 行间距最大宽度空一行</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt04-语言项item-定义时左花括号brace位置应该与语言项保持同一行"><a class="header" href="#pfmt04-语言项item-定义时左花括号brace位置应该与语言项保持同一行">P.FMT.04 语言项（Item) 定义时左花括号（brace）位置应该与语言项保持同一行</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt05-存在多个标识符时应该保持块状block缩进"><a class="header" href="#pfmt05-存在多个标识符时应该保持块状block缩进">P.FMT.05 存在多个标识符时应该保持块状（Block）缩进</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt06-当有多行表达式操作时操作符应该置于行首"><a class="header" href="#pfmt06-当有多行表达式操作时操作符应该置于行首">P.FMT.06 当有多行表达式操作时，操作符应该置于行首</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt07-枚举变体和结构体字段都应左对齐"><a class="header" href="#pfmt07-枚举变体和结构体字段都应左对齐">P.FMT.07 枚举变体和结构体字段都应左对齐</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt08-函数参数超过五个或导入模块个数超过四个需换行"><a class="header" href="#pfmt08-函数参数超过五个或导入模块个数超过四个需换行">P.FMT.08 函数参数超过五个或导入模块个数超过四个需换行</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt09-不同的场景使用不同的空格风格"><a class="header" href="#pfmt09-不同的场景使用不同的空格风格">P.FMT.09 不同的场景，使用不同的空格风格</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt10-match-分支应该具有良好的可读性"><a class="header" href="#pfmt10-match-分支应该具有良好的可读性">P.FMT.10 match 分支应该具有良好的可读性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt11-导入模块分组应该具有良好的可读性"><a class="header" href="#pfmt11-导入模块分组应该具有良好的可读性">P.FMT.11 导入模块分组应该具有良好的可读性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt12-声明宏分支应该具有良好的可读性"><a class="header" href="#pfmt12-声明宏分支应该具有良好的可读性">P.FMT.12 声明宏分支应该具有良好的可读性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt13-具名结构体字段初始化时不要省略字段名"><a class="header" href="#pfmt13-具名结构体字段初始化时不要省略字段名">P.FMT.13 具名结构体字段初始化时不要省略字段名</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt14-extern-外部函数需要显式指定-c-abi"><a class="header" href="#pfmt14-extern-外部函数需要显式指定-c-abi">P.FMT.14 extern 外部函数需要显式指定 C-ABI</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt15-解构元组的时候允许使用来指代剩余元素"><a class="header" href="#pfmt15-解构元组的时候允许使用来指代剩余元素">P.FMT.15 解构元组的时候允许使用..来指代剩余元素</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfmt16-不要将派生宏中多个不相关的特质合并为同一行"><a class="header" href="#pfmt16-不要将派生宏中多个不相关的特质合并为同一行">P.FMT.16 不要将派生宏中多个不相关的特质合并为同一行</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-annotations-and-documentation"><a class="header" href="#23-annotations-and-documentation">2.3 Annotations and Documentation</a></h1>
<p>In Rust, there are two types of annotations: normal annotations and documentation annotations. Normal comments use <code>//</code> or <code>/* ... */</code>, and document comments use <code>///</code>, <code>//! </code> or <code>/** ... **/</code>.</p>
<p>When referring to &quot;comments&quot; in the principles and rules, this includes both normal comments and document comments. When &quot;documentation&quot; is mentioned, it refers specifically to documentation comments.</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<ol>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505: API Annotation Conventions</a></li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1574-more-api-documentation-conventions.md">RFC 1574: API Documentation Conventions</a></li>
<li><a href="https://www.tangramvision.com/blog/making-great-docs-with-rustdoc">Making Great Docs with Rustdoc</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">Rust Doc book</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcmt01-the-code-can-be-self-annotated-and-the-documentation-should-be-concise"><a class="header" href="#pcmt01-the-code-can-be-self-annotated-and-the-documentation-should-be-concise">P.CMT.01 The code can be self-annotated, and the documentation should be concise</a></h1>
<p><strong>[Description]</strong></p>
<p>一、The code can be self-annotated, avoiding redundant ordinary code comments.</p>
<p>Comments are important, but the best code is documentation itself. Meaningful type, function, and variable names are far better than ambiguous names explained by comments. Comments are used when meaningful type names, function names, and variable names cannot express complete semantics.</p>
<p>Don't describe obvious phenomena, and never translate code in natural language as comments.</p>
<p>二、The documentation should be concise.</p>
<ol>
<li>The content and terms in the documentation comments should be as short and concise as possible, and should not be too long. Make sure your code is well commented and understandable by others. Good comments convey the context and purpose of the code.</li>
<li>Comments are always structured around two key points:
<ul>
<li>What: Used to describe what the code implement.</li>
<li>How: Used to describe how to use code your code.</li>
</ul>
</li>
<li>The natural language used for comments and documentation comments should be consistent.</li>
<li>Rust project documentation should always be built on the <code>rustdoc</code> tool. <code>rustdoc</code> supports the Markdown format. To make the documentation more beautiful and readable, the documentation comments should use the Markdown format.</li>
</ol>
<p><strong>[Good Case]</strong></p>
<p>Module Based Documentation Comments. From Rust std <code>std::vec</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good

//! # The Rust core allocation and collections library
//!
//! This library provides smart pointers and collections for managing
//! heap-allocated values.
//!
//! This library, like libcore, normally doesn’t need to be used directly
//! since its contents are re-exported in the [`std` crate](../std/index.html).
//! Crates that use the `#![no_std]` attribute however will typically
//! not depend on `std`, so they’d use this crate instead.
//!
//! ## Boxed values
//!
//! The [`Box`] type is a smart pointer type. There can only be one owner of a
//! [`Box`], and the owner can decide to mutate the contents, which live on the
//! heap.
<span class="boring">}
</span></code></pre></pre>
<p>General Documentation Comments. From Rust std <code>Vec::new</code> method.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good

/// Constructs a new, empty `Vec&lt;T&gt;`.
///
/// The vector will not allocate until elements are pushed onto it.
///
/// # Examples
///
/// ```
/// # #![allow(unused_mut)]
/// let mut vec: Vec&lt;i32&gt; = Vec::new();
/// ```
#[inline]
#[rustc_const_stable(feature = &quot;const_vec_new&quot;, since = &quot;1.39.0&quot;)]
#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
pub const fn new() -&gt; Self {
    Vec { buf: RawVec::NEW, len: 0 }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcmt02-comments-should-have-a-width-limit"><a class="header" href="#pcmt02-comments-should-have-a-width-limit">P.CMT.02 Comments should have a width limit</a></h1>
<p><strong>[Description]</strong></p>
<p>The width of each comment line should not be too long and needs to be set at a certain width, no more than 120, which help improve readability.</p>
<p>In <code>rustfmt</code>, the <code>comment_width</code> with <code>wrap_comments</code> configuration item can automatically split comments that exceed the width limit into multiple lines.</p>
<p><strong>Note</strong>: The <code>use_small_heuristics</code> configuration item of <code>rustfmt</code> does not include <code>comment_width</code>.</p>
<p><strong>[Bad Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad
// Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Good Case]</strong></p>
<p>When <code>comment_width=80</code> and <code>wrap_comments=true</code>.</p>
<p><strong>Note</strong>: Here <code>wrap_comments</code> does not use the default value and needs to be configured to true.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good
// Lorem ipsum dolor sit amet, consectetur adipiscing elit,
// sed do eiusmod tempor incididunt ut labore et dolore
// magna aliqua. Ut enim ad minim veniam, quis nostrud
// exercitation ullamco laboris nisi ut aliquip ex ea
// commodo consequat.
<span class="boring">}
</span></code></pre></pre>
<p><strong>[rustfmt configuration]</strong></p>
<table><thead><tr><th>Parameter</th><th>Optional</th><th>stable or not</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#comment_width"><code>comment_width</code></a></td><td>80(default)</td><td>No</td><td>Specify the maximum width allowed for a line of comments</td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#wrap_comments"><code>wrap_comments</code></a></td><td>false(default), true(suggestion)</td><td>No</td><td>Running multi-line comments automatically change to multi-line comments by maximum width</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcmt03-use-line-comments-and-avoid-block-comments"><a class="header" href="#pcmt03-use-line-comments-and-avoid-block-comments">P.CMT.03 Use line comments and avoid block comments</a></h1>
<p><strong>[Description]</strong></p>
<p>Try to use line comments (<code>//</code> or <code>///</code>) rather than block comments. This is a convention in the Rust community.</p>
<p>For documentation comments, use <code>//! </code>, in other cases <code>///</code> is better.</p>
<p>Note: <code>#! [doc]</code> and <code>#[doc]</code> have a special role in simplifying document comments, and it is not necessary to force them into <code>//! </code> or <code>//</code>.</p>
<p><strong>[Bad Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad

/*
 * Wait for the main task to return, and set the process error code
 * appropriately.
 */
mod tests {
    //! This module contains tests

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Good Case]</strong></p>
<p>When <code>normalize_comments = true</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good

// Wait for the main task to return, and set the process error code
// appropriately.

// Good
// When defining modules using the `mod` keyword, 
// it is better to use `///` on top of `mod`.

/// This module contains tests
mod tests {
    // ...
}

// Good
#[doc = &quot;Example item documentation&quot;]
pub enum Foo {}
<span class="boring">}
</span></code></pre></pre>
<p><strong>【rustfmt configuration】</strong></p>
<table><thead><tr><th>Parameter</th><th>Optional</th><th>Stable or not</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#normalize_comments"><code>normalize_comments</code></a></td><td>false(default) true(suggestionn)</td><td>No</td><td>Convert the <code>/**/</code> comment to <code>/</code></td></tr>
<tr><td><a href="https://rust-lang.github.io/rustfmt/?#normalize_doc_attributes"><code>normalize_doc_attributes</code></a></td><td>false(default)</td><td>No</td><td>Convert the <code>#! [doc]</code> and <code>#[doc]</code> annotations to <code>//! </code> and <code>///</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcmt04-file-header-comments-include-a-copyright-notice"><a class="header" href="#pcmt04-file-header-comments-include-a-copyright-notice">P.CMT.04 File header comments include a copyright notice</a></h1>
<p><strong>[Description]</strong></p>
<p>File header (i.e., module-level) comments should include the copyright notice first. If additional content needs to be added to the file header comments, it can be added under the copyright notice.</p>
<p>May include:</p>
<ol>
<li>A description of the function of the document.</li>
<li>Author.</li>
<li>Creation date and last modification date.</li>
<li>Notes.</li>
<li>Open source license (e.g., Apache 2.0, BSD, LGPL, GPL).</li>
<li>Other.</li>
</ol>
<p>The format of the copyright notice is as follows:</p>
<ul>
<li>中文版：<code>版权所有（c）XXX 技术有限公司 2015-2022</code>。</li>
<li>English version: <code>Copyright (c) XXX Technologies Co. Ltd. 2015-2022. All rights reserved. Licensed under Apache-2.0.</code></li>
</ul>
<p>Its content can be adjusted to participate in the following detailed description:</p>
<ul>
<li><code>2015-2022</code> can be modified as needed. 2015 is the year the file was first created and 2022 is the year the file was last modified. It is possible to write only one creation year, so that the copyright notice does not need to be changed if the file is modified frequently.</li>
<li>For internal use, there is no need to add <code>All rights reserved</code>.</li>
<li><code>Licensed under Apache-2.0.</code>, if it is open source then you can add the license statement.</li>
</ul>
<p>Caution when writing copyright notes:</p>
<ul>
<li>Copyright notes should be written from the top of the file header.</li>
<li>The header comment should contain the &quot;copyright notice&quot; first, followed by the rest of the content.</li>
<li>Optional content should be added as needed to avoid empty formatting without content.</li>
<li>Maintain uniform formatting, either by the project or by the larger context.</li>
<li>Maintain a neat layout, with line breaks aligned.</li>
</ul>
<p><strong>[Good Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good
// 版权所有（c）XXX 技术有限公司 2015-2022。

// Or

// Good
// Copyright (c) XXX Technologies Co.Ltd. 2015-2022. 
// All rights reserved. Licensed under Apache-2.0.
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcmt05-use-fixme-and-todo-in-comments-to-help-with-task-collaboration"><a class="header" href="#pcmt05-use-fixme-and-todo-in-comments-to-help-with-task-collaboration">P.CMT.05 Use <code>FIXME</code> and <code>TODO</code> in comments to help with task collaboration</a></h1>
<p><strong>[Description]</strong></p>
<p>Collaboration can be facilitated by turning on <code>FIXME</code> and <code>TODO</code> in the comments.</p>
<p>Note: This entry is not suitable for use with <code>rustfmt</code> related configuration items <code>report_fixme</code> and <code>report_todo</code>, which have been removed in <code>rustfmt</code> v2.0.</p>
<p><strong>[Good Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good
// TODO(calebcartwright): consider enabling box_patterns feature gate
fn annotation_type_for_level(level: Level) -&gt; AnnotationType {
    match level {
        Level::Bug | Level::Fatal | Level::Error =&gt; AnnotationType::Error,
        Level::Warning =&gt; AnnotationType::Warning,
        Level::Note =&gt; AnnotationType::Note,
        Level::Help =&gt; AnnotationType::Help,
        // FIXME(#59346): Not sure how to map these two levels
        Level::Cancelled | Level::FailureNote =&gt; AnnotationType::Error,
        Level::Allow =&gt; panic!(&quot;Should not call with Allow&quot;),
    }
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcmt01-error-comments-need-to-added-the-documentation-of-functions-that-return-result-types-in-the-public"><a class="header" href="#gcmt01-error-comments-need-to-added-the-documentation-of-functions-that-return-result-types-in-the-public">G.CMT.01 Error comments need to added the documentation of functions that return <code>Result</code> types in the public</a></h1>
<p><strong>[Level]</strong> Suggestion</p>
<p><strong>[Description]</strong></p>
<p>In the public (pub) documentation of functions that return <code>Result</code> types, it is recommended to add <code># Error</code> comments to explain what scenarios the function will return what kind of error type, so that users can easily handle errors.</p>
<p>Description: This rule can be detected by cargo clippy, but it does not warn by default.</p>
<p><strong>[Bad Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::missing_errors_doc)]

<span class="boring">fn main() {
</span>use std::io;
// Bad： Clippy will be warned &quot;warning: docs for function returning `Result` missing `# Errors` section&quot;
pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Good Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::missing_errors_doc)]

<span class="boring">fn main() {
</span>use std::io;
// Good：adding normatives Errors documentation comments

/// # Errors
///
/// Will return `Err` if `filename` does not exist or the user does not have
/// permission to read it.
pub fn read(filename: String) -&gt; io::Result&lt;String&gt; {
    unimplemented!();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Lint detection]</strong></p>
<table><thead><tr><th>Lint name</th><th>Clippy detectable</th><th>Rustc detectable</th><th>Lint Group</th><th>Default level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_errors_doc">missing_errors_doc </a></td><td>yes</td><td>no</td><td>Style</td><td>allow</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcmt02-if-a-panic-occurs-under-certain-circumstances-in-the-public-api-add-a-panic-comment-to-the-corresponding-document"><a class="header" href="#gcmt02-if-a-panic-occurs-under-certain-circumstances-in-the-public-api-add-a-panic-comment-to-the-corresponding-document">G.CMT.02 If a Panic occurs under certain circumstances in the public API, add a Panic comment to the corresponding document</a></h1>
<p><strong>[Level]</strong> Requirements</p>
<p><strong>[Description]</strong></p>
<p>In the public (pub) function documentation, it is recommended to add <code># Panic</code> comments to explain under what conditions the function will Panic, so that users can pre-process it.</p>
<p>Description: This rule is detected by cargo clippy. It does not warn by default.</p>
<p><strong>[Bad Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::missing_panics_doc)]

<span class="boring">fn main() {
</span>// Bad：If do not add Panic relevant comments.`Clippy` will raise error: &quot;warning: docs for function which may panic missing `# Panics` section&quot;。
pub fn divide_by(x: i32, y: i32) -&gt; i32 {
    if y == 0 {
        panic!(&quot;Cannot divide by 0&quot;)
    } else {
        x / y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Good Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![warn(clippy::missing_panics_doc)]

<span class="boring">fn main() {
</span>// Good：Added Panic comments
/// # Panics
///
/// Will panic if y is 0
pub fn divide_by(x: i32, y: i32) -&gt; i32 {
    if y == 0 {
        panic!(&quot;Cannot divide by 0&quot;)
    } else {
        x / y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Lint detect]</strong></p>
<table><thead><tr><th>Lint name</th><th>Clippy detectable</th><th>Rustc detectable</th><th>Lint Group</th><th>Default level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#missing_panics_doc">missing_panics_doc </a></td><td>yes</td><td>no</td><td>Style</td><td>allow</td></tr>
</tbody></table>
<p>Default is <code>allow</code>，But this pricipal need to be set <code>#![warn(clippy::missing_panics_doc)]</code>。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcmt03-use-spaces-in-document-comments-instead-of-tabs"><a class="header" href="#gcmt03-use-spaces-in-document-comments-instead-of-tabs">G.CMT.03 Use spaces in document comments instead of tabs</a></h1>
<p><strong>[Level]</strong> Suggestion</p>
<p><strong>[Description]</strong></p>
<p>Rust code style promotes the use of <strong>four spaces</strong> instead of tabs, and <strong>four spaces</strong> should be used consistently in the documentation comments.</p>
<p><strong>[Bad Case]</strong></p>
<p>Tab is used in the following document comments.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Bad：Tab indentation is used in document comments
///
/// Struct to hold two strings:
/// 	- first		one
/// 	- second	one
pub struct DoubleString {
   ///
   /// 	- First String:
   /// 		- needs to be inside here
   first_string: String,
   ///
   /// 	- Second String:
   /// 		- needs to be inside here
   second_string: String,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Good Case]</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good：Four spaces indentation is used in document comments
///
/// Struct to hold two strings:
///     - first        one
///     - second    one
pub struct DoubleString {
   ///
   ///     - First String:
   ///         - needs to be inside here
   first_string: String,
   ///
   ///     - Second String:
   ///         - needs to be inside here
   second_string: String,
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>[Lint detect]</strong></p>
<table><thead><tr><th>Lint name</th><th>Clippy detectable</th><th>Rustc detectable</th><th>Lint Group</th><th>Default level</th></tr></thead><tbody>
<tr><td><a href="https://rust-lang.github.io/rust-clippy/master/index.html#tabs_in_doc_comments">tabs_in_doc_comments </a></td><td>yes</td><td>no</td><td>Style</td><td>warn</td></tr>
<tr><td>s</td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编码实践"><a class="header" href="#编码实践">编码实践</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常量"><a class="header" href="#常量">常量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcns01-对于科学计算中涉及浮点数近似值的常量宜使用预定义常量"><a class="header" href="#gcns01-对于科学计算中涉及浮点数近似值的常量宜使用预定义常量">G.CNS.01 对于科学计算中涉及浮点数近似值的常量宜使用预定义常量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcns02-不应断言常量布尔类型"><a class="header" href="#gcns02-不应断言常量布尔类型">G.CNS.02 不应断言常量布尔类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcns03-不应将内部可变性容器声明为常量"><a class="header" href="#gcns03-不应将内部可变性容器声明为常量">G.CNS.03 不应将内部可变性容器声明为常量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcns04-不应在常量定义中增加显式的-static-生命周期"><a class="header" href="#gcns04-不应在常量定义中增加显式的-static-生命周期">G.CNS.04 不应在常量定义中增加显式的 'static 生命周期</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcns05-对于适用-const-fn-的函数或方法宜尽可能地使用-const-fn"><a class="header" href="#gcns05-对于适用-const-fn-的函数或方法宜尽可能地使用-const-fn">G.CNS.05 对于适用 const fn 的函数或方法宜尽可能地使用 const fn</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="静态变量"><a class="header" href="#静态变量">静态变量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gstv01-不宜直接使用可变静态变量作为全局变量"><a class="header" href="#gstv01-不宜直接使用可变静态变量作为全局变量">G.STV.01 不宜直接使用可变静态变量作为全局变量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="本地变量"><a class="header" href="#本地变量">本地变量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pvar01-一般情况下避免先声明可变变量再赋值"><a class="header" href="#pvar01-一般情况下避免先声明可变变量再赋值">P.VAR.01 一般情况下避免先声明可变变量再赋值</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pvar02-利用变量遮蔽功能保证变量安全使用"><a class="header" href="#pvar02-利用变量遮蔽功能保证变量安全使用">P.VAR.02 利用变量遮蔽功能保证变量安全使用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gvar01-以解构元组方式定义超过四个变量时不应使用太多无意义变量名"><a class="header" href="#gvar01-以解构元组方式定义超过四个变量时不应使用太多无意义变量名">G.VAR.01 以解构元组方式定义超过四个变量时不应使用太多无意义变量名</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gvar02-不应使用非-ascii-字符作为标识符"><a class="header" href="#gvar02-不应使用非-ascii-字符作为标识符">G.VAR.02 不应使用非 ASCII 字符作为标识符</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gvar03-变量遮蔽功能应当合理使用"><a class="header" href="#gvar03-变量遮蔽功能应当合理使用">G.VAR.03 变量遮蔽功能应当合理使用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gvar04-避免因局部变量过大而导致的大量栈分配"><a class="header" href="#gvar04-避免因局部变量过大而导致的大量栈分配">G.VAR.04 避免因局部变量过大而导致的大量栈分配</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptyp01-必要时应使类型可以表达更明确的语义而不是只是直接使用原生类型"><a class="header" href="#ptyp01-必要时应使类型可以表达更明确的语义而不是只是直接使用原生类型">P.TYP.01 必要时，应使类型可以表达更明确的语义，而不是只是直接使用原生类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtyp01-类型转换尽可能使用安全的转换函数代替-as"><a class="header" href="#gtyp01-类型转换尽可能使用安全的转换函数代替-as">G.TYP.01 类型转换尽可能使用安全的转换函数代替 as</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtyp02-数字字面量在使用的时候应该明确标注类型"><a class="header" href="#gtyp02-数字字面量在使用的时候应该明确标注类型">G.TYP.02 数字字面量在使用的时候应该明确标注类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtyp03-不要用数字类型边界值判断能否安全转换而应使用-try_from-方法"><a class="header" href="#gtyp03-不要用数字类型边界值判断能否安全转换而应使用-try_from-方法">G.TYP.03 不要用数字类型边界值判断能否安全转换，而应使用 try_from 方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="布尔"><a class="header" href="#布尔">布尔</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypbol01-不应将布尔值和布尔字面量进行比较"><a class="header" href="#gtypbol01-不应将布尔值和布尔字面量进行比较">G.TYP.BOL.01 不应将布尔值和布尔字面量进行比较</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypbol02-如果-match-匹配表达式为布尔类型宜使用-if-表达式来代替"><a class="header" href="#gtypbol02-如果-match-匹配表达式为布尔类型宜使用-if-表达式来代替">G.TYP.BOL.02 如果 match 匹配表达式为布尔类型，宜使用 if 表达式来代替</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypbol03-不应将数字类型转换为布尔值"><a class="header" href="#gtypbol03-不应将数字类型转换为布尔值">G.TYP.BOL.03 不应将数字类型转换为布尔值</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypbol04-禁止在if表达式条件中使用块结构"><a class="header" href="#gtypbol04-禁止在if表达式条件中使用块结构">G.TYP.BOL.04 禁止在if表达式条件中使用块结构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypbol05-非必要时布尔运算应使用逻辑运算符-而非位运算符-"><a class="header" href="#gtypbol05-非必要时布尔运算应使用逻辑运算符-而非位运算符-">G.TYP.BOL.05 非必要时，布尔运算应使用逻辑运算符( &amp;&amp;/||)而非位运算符 (&amp;/|)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypbol06-不应使用数字代替布尔值"><a class="header" href="#gtypbol06-不应使用数字代替布尔值">G.TYP.BOL.06 不应使用数字代替布尔值</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符"><a class="header" href="#字符">字符</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypchr01-不应将字符字面量强制转换为-u8"><a class="header" href="#gtypchr01-不应将字符字面量强制转换为-u8">G.TYP.CHR.01 不应将字符字面量强制转换为 u8</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypchr02-字符串方法中如果需要单个字符的值作为参数宜使用字符而非字符串"><a class="header" href="#gtypchr02-字符串方法中如果需要单个字符的值作为参数宜使用字符而非字符串">G.TYP.CHR.02 字符串方法中如果需要单个字符的值作为参数，宜使用字符而非字符串</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypchr03-需要将整数转换为字符时应使用安全转换函数而非-transmute"><a class="header" href="#gtypchr03-需要将整数转换为字符时应使用安全转换函数而非-transmute">G.TYP.CHR.03 需要将整数转换为字符时，应使用安全转换函数，而非 transmute</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="整数"><a class="header" href="#整数">整数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypint01-在用整数计算的时候需要考虑整数溢出回绕和截断的风险"><a class="header" href="#gtypint01-在用整数计算的时候需要考虑整数溢出回绕和截断的风险">G.TYP.INT.01 在用整数计算的时候需要考虑整数溢出、回绕和截断的风险</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypint02-避免在有符号整数和无符号整数之间进行强制转换"><a class="header" href="#gtypint02-避免在有符号整数和无符号整数之间进行强制转换">G.TYP.INT.02 避免在有符号整数和无符号整数之间进行强制转换</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypint03-对负数取模计算的时候不应使用-"><a class="header" href="#gtypint03-对负数取模计算的时候不应使用-">G.TYP.INT.03 对负数取模计算的时候不应使用 %</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypflt01-使用浮点数字面量时要警惕是否存在被rust编译器截断的风险"><a class="header" href="#gtypflt01-使用浮点数字面量时要警惕是否存在被rust编译器截断的风险">G.TYP.FLT.01 使用浮点数字面量时，要警惕是否存在被Rust编译器截断的风险</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypflt02-从任何数字类型转换为浮点类型时注意避免损失精度"><a class="header" href="#gtypflt02-从任何数字类型转换为浮点类型时注意避免损失精度">G.TYP.FLT.02 从任何数字类型转换为浮点类型时注意避免损失精度</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypflt03-对精度高要求的场景下使用浮点数进行运算和比较时需要注意精度损失"><a class="header" href="#gtypflt03-对精度高要求的场景下使用浮点数进行运算和比较时需要注意精度损失">G.TYP.FLT.03 对精度高要求的场景下，使用浮点数进行运算和比较时需要注意精度损失</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypflt04-宜使用rust内置方法处理浮点数计算"><a class="header" href="#gtypflt04-宜使用rust内置方法处理浮点数计算">G.TYP.FLT.04 宜使用Rust内置方法处理浮点数计算</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypflt05-禁止在浮点数和整数相互转换时使用-transmute"><a class="header" href="#gtypflt05-禁止在浮点数和整数相互转换时使用-transmute">G.TYP.FLT.05 禁止在浮点数和整数相互转换时使用 transmute</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="切片"><a class="header" href="#切片">切片</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptypslc01-宜使用切片迭代器来代替手工索引"><a class="header" href="#ptypslc01-宜使用切片迭代器来代替手工索引">P.TYP.SLC.01 宜使用切片迭代器来代替手工索引</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptypslc02-宜使用切片模式来提升代码的可读性"><a class="header" href="#ptypslc02-宜使用切片模式来提升代码的可读性">P.TYP.SLC.02 宜使用切片模式来提升代码的可读性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="元组"><a class="header" href="#元组">元组</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtyptup01-使用元组时其元素不宜超过3个"><a class="header" href="#gtyptup01-使用元组时其元素不宜超过3个">G.TYP.TUP.01 使用元组时，其元素不宜超过3个</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="固定长度数组"><a class="header" href="#固定长度数组">固定长度数组</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtyparr01-创建大全局数组时宜使用静态变量而非常量"><a class="header" href="#gtyparr01-创建大全局数组时宜使用静态变量而非常量">G.TYP.ARR.01 创建大全局数组时宜使用静态变量而非常量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtyparr02-使用数组索引时禁止越界访问"><a class="header" href="#gtyparr02-使用数组索引时禁止越界访问">G.TYP.ARR.02 使用数组索引时禁止越界访问</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtyparr03-当数组元素为原生数据类型primitive排序时优先选用非稳定排序"><a class="header" href="#gtyparr03-当数组元素为原生数据类型primitive排序时优先选用非稳定排序">G.TYP.ARR.03 当数组元素为原生数据类型（Primitive），排序时优先选用非稳定排序</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="动态数组"><a class="header" href="#动态数组">动态数组</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptypvec01-非必要时不宜使用动态数组"><a class="header" href="#ptypvec01-非必要时不宜使用动态数组">P.TYP.VEC.01 非必要时不宜使用动态数组</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptypvec02-创建动态数组时宜预先分配足够容量避免后续操作中产生多次分配"><a class="header" href="#ptypvec02-创建动态数组时宜预先分配足够容量避免后续操作中产生多次分配">P.TYP.VEC.02 创建动态数组时，宜预先分配足够容量，避免后续操作中产生多次分配</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypvec01-禁止访问未初始化的数组"><a class="header" href="#gtypvec01-禁止访问未初始化的数组">G.TYP.VEC.01 禁止访问未初始化的数组</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="结构体"><a class="header" href="#结构体">结构体</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptypsct01-为结构体实现构造性方法时避免构造后再初始化的情况"><a class="header" href="#ptypsct01-为结构体实现构造性方法时避免构造后再初始化的情况">P.TYP.SCT.01 为结构体实现构造性方法时，避免构造后再初始化的情况</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptypsct02-结构体实例需要默认实现时宜使用default特质"><a class="header" href="#ptypsct02-结构体实例需要默认实现时宜使用default特质">P.TYP.SCT.02 结构体实例需要默认实现时，宜使用Default特质</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypsct01-对外导出的公开的-struct宜添加non_exhaustive属性"><a class="header" href="#gtypsct01-对外导出的公开的-struct宜添加non_exhaustive属性">G.TYP.SCT.01 对外导出的公开的 Struct，宜添加#[non_exhaustive]属性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypsct02-当结构体中有超过三个布尔类型的字段宜将其独立为新的枚举类"><a class="header" href="#gtypsct02-当结构体中有超过三个布尔类型的字段宜将其独立为新的枚举类">G.TYP.SCT.02 当结构体中有超过三个布尔类型的字段，宜将其独立为新的枚举类</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypsct03-宜使用结构体功能更新语法来提升代码可读性"><a class="header" href="#gtypsct03-宜使用结构体功能更新语法来提升代码可读性">G.TYP.SCT.03 宜使用结构体功能更新语法来提升代码可读性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="枚举体"><a class="header" href="#枚举体">枚举体</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypenm01-合理使用map和and_then方法"><a class="header" href="#gtypenm01-合理使用map和and_then方法">G.TYP.ENM.01 合理使用map和and_then方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypenm02-不应自行创建空枚举"><a class="header" href="#gtypenm02-不应自行创建空枚举">G.TYP.ENM.02 不应自行创建空枚举</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypenm03-在使用类似-c-语言的枚举写法且使用reprisizeusize-布局时注意-32位架构上截断的问题"><a class="header" href="#gtypenm03-在使用类似-c-语言的枚举写法且使用reprisizeusize-布局时注意-32位架构上截断的问题">G.TYP.ENM.03 在使用类似 C 语言的枚举写法且使用repr(isize/usize) 布局时注意 32位架构上截断的问题</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypenm04-不宜在use语句中引入enum的全部变体variants"><a class="header" href="#gtypenm04-不宜在use语句中引入enum的全部变体variants">G.TYP.ENM.04 不宜在use语句中引入Enum的全部变体（variants）</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypenm05-对外导出的公开enum宜添加non_exhaustive属性"><a class="header" href="#gtypenm05-对外导出的公开enum宜添加non_exhaustive属性">G.TYP.ENM.05 对外导出的公开Enum，宜添加#[non_exhaustive]属性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtypenm06-enum内变体的大小差异不宜过大"><a class="header" href="#gtypenm06-enum内变体的大小差异不宜过大">G.TYP.ENM.06 Enum内变体的大小差异不宜过大</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表达式"><a class="header" href="#表达式">表达式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gexp01-当需要对表达式求值后重新赋值时宜使用复合赋值模式"><a class="header" href="#gexp01-当需要对表达式求值后重新赋值时宜使用复合赋值模式">G.EXP.01 当需要对表达式求值后重新赋值时，宜使用复合赋值模式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gexp02-不宜在比较中使用不兼容的位掩码"><a class="header" href="#gexp02-不宜在比较中使用不兼容的位掩码">G.EXP.02 不宜在比较中使用不兼容的位掩码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gexp03-不应利用数组表达式的边界检查来-panic而应使用断言"><a class="header" href="#gexp03-不应利用数组表达式的边界检查来-panic而应使用断言">G.EXP.03 不应利用数组表达式的边界检查来 Panic，而应使用断言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gexp04-自增或自减运算使用或-"><a class="header" href="#gexp04-自增或自减运算使用或-">G.EXP.04 自增或自减运算使用+=或-=</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gexp05-使用括号来清楚表示表达式的计算顺序"><a class="header" href="#gexp05-使用括号来清楚表示表达式的计算顺序">G.EXP.05 使用括号来清楚表示表达式的计算顺序</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gexp06-避免在比较中添加无用的掩码操作"><a class="header" href="#gexp06-避免在比较中添加无用的掩码操作">G.EXP.06 避免在比较中添加无用的掩码操作</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="控制流程"><a class="header" href="#控制流程">控制流程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pctf01-避免滥用迭代器"><a class="header" href="#pctf01-避免滥用迭代器">P.CTF.01 避免滥用迭代器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pctf02-优先使用模式匹配而非判断后再取值"><a class="header" href="#pctf02-优先使用模式匹配而非判断后再取值">P.CTF.02 优先使用模式匹配而非判断后再取值</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gctf01-当需要通过多个if判断来比较大小来区分不同情况时优先使用match和cmp来代替if表达式"><a class="header" href="#gctf01-当需要通过多个if判断来比较大小来区分不同情况时优先使用match和cmp来代替if表达式">G.CTF.01 当需要通过多个if判断来比较大小来区分不同情况时，优先使用match和cmp来代替if表达式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gctf02-if条件表达式分支中如果包含了else-if分支也应该包含else分支"><a class="header" href="#gctf02-if条件表达式分支中如果包含了else-if分支也应该包含else分支">G.CTF.02 if条件表达式分支中如果包含了else if分支也应该包含else分支</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gctf03-如果要通过-if-条件表达式来判断是否-panic请优先使用断言"><a class="header" href="#gctf03-如果要通过-if-条件表达式来判断是否-panic请优先使用断言">G.CTF.03 如果要通过 if 条件表达式来判断是否 Panic，请优先使用断言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gctf04-在-match-分支的-guard-语句中不要使用带有副作用的条件表达式"><a class="header" href="#gctf04-在-match-分支的-guard-语句中不要使用带有副作用的条件表达式">G.CTF.04 在 Match 分支的 Guard 语句中不要使用带有副作用的条件表达式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="字符串"><a class="header" href="#字符串">字符串</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pstr01-处理字符串元素时优先按字节处理而非字符"><a class="header" href="#pstr01-处理字符串元素时优先按字节处理而非字符">P.STR.01 处理字符串元素时优先按字节处理而非字符</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pstr02-创建字符串时宜预先分配大约足够的容量来避免后续操作中产生多次分配"><a class="header" href="#pstr02-创建字符串时宜预先分配大约足够的容量来避免后续操作中产生多次分配">P.STR.02 创建字符串时，宜预先分配大约足够的容量来避免后续操作中产生多次分配</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pstr03-在使用内建字符串处理函数或方法的时候应注意避免隐藏的嵌套迭代或多次迭代"><a class="header" href="#pstr03-在使用内建字符串处理函数或方法的时候应注意避免隐藏的嵌套迭代或多次迭代">P.STR.03 在使用内建字符串处理函数或方法的时候，应注意避免隐藏的嵌套迭代或多次迭代</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pstr04-只在合适的场景下使用正则表达式第三方库regex"><a class="header" href="#pstr04-只在合适的场景下使用正则表达式第三方库regex">P.STR.04 只在合适的场景下，使用正则表达式第三方库regex</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pstr05-在拼接字符串时优先使用format"><a class="header" href="#pstr05-在拼接字符串时优先使用format">P.STR.05 在拼接字符串时，优先使用format!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gstr01-在实现display特质时不应调用to_string方法"><a class="header" href="#gstr01-在实现display特质时不应调用to_string方法">G.STR.01 在实现Display特质时不应调用to_string()方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gstr02-在追加字符串时使用push_str方法"><a class="header" href="#gstr02-在追加字符串时使用push_str方法">G.STR.02 在追加字符串时使用push_str方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gstr03-将只包含-ascii字符的字符串字面量转为字节序列可以直接使用bstr-语法代替调用as_bytes方法"><a class="header" href="#gstr03-将只包含-ascii字符的字符串字面量转为字节序列可以直接使用bstr-语法代替调用as_bytes方法">G.STR.03 将只包含 ASCII字符的字符串字面量转为字节序列可以直接使用b&quot;str&quot; 语法代替调用as_bytes方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gstr04-需要辨别字符串的字符开头或结尾字符时不应按字符迭代比较"><a class="header" href="#gstr04-需要辨别字符串的字符开头或结尾字符时不应按字符迭代比较">G.STR.04 需要辨别字符串的字符开头或结尾字符时，不应按字符迭代比较</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gstr05-对字符串按指定位置进行切片的时候需要小心破坏其-utf-8-编码"><a class="header" href="#gstr05-对字符串按指定位置进行切片的时候需要小心破坏其-utf-8-编码">G.STR.05 对字符串按指定位置进行切片的时候需要小心破坏其 UTF-8 编码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集合容器"><a class="header" href="#集合容器">集合容器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pclt01-创建hashmapvecdeque时可以预先分配大约足够的容量来避免后续操作中产生多次分配"><a class="header" href="#pclt01-创建hashmapvecdeque时可以预先分配大约足够的容量来避免后续操作中产生多次分配">P.CLT.01 创建HashMap、VecDeque时，可以预先分配大约足够的容量来避免后续操作中产生多次分配</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gclt01-非必要情况下不要使用linkedlist而用vec或vecdeque代替"><a class="header" href="#gclt01-非必要情况下不要使用linkedlist而用vec或vecdeque代替">G.CLT.01 非必要情况下，不要使用LinkedList，而用Vec或VecDeque代替</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数设计"><a class="header" href="#函数设计">函数设计</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfud01-传递到闭包的变量建议单独重新绑定"><a class="header" href="#pfud01-传递到闭包的变量建议单独重新绑定">P.FUD.01 传递到闭包的变量建议单独重新绑定</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfud02-函数返回值不要使用-return"><a class="header" href="#pfud02-函数返回值不要使用-return">P.FUD.02 函数返回值不要使用 return</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gfud01-函数参数最长不要超过五个"><a class="header" href="#gfud01-函数参数最长不要超过五个">G.FUD.01 函数参数最长不要超过五个</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gfud02-当函数参数实现了-copy并且是按值传入如果值可能会太大则宜考虑按引用传递"><a class="header" href="#gfud02-当函数参数实现了-copy并且是按值传入如果值可能会太大则宜考虑按引用传递">G.FUD.02 当函数参数实现了 Copy，并且是按值传入，如果值可能会太大，则宜考虑按引用传递</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gfud03-当函数参数出现太多-bool-类型的参数时应该考虑将其封装为自定义的结构体或枚举"><a class="header" href="#gfud03-当函数参数出现太多-bool-类型的参数时应该考虑将其封装为自定义的结构体或枚举">G.FUD.03 当函数参数出现太多 bool 类型的参数时，应该考虑将其封装为自定义的结构体或枚举</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gfud04-当copy-类型的足够小的值作为函数参数时应该按值by-value传入而不是引用by-ref"><a class="header" href="#gfud04-当copy-类型的足够小的值作为函数参数时应该按值by-value传入而不是引用by-ref">G.FUD.04 当Copy 类型的足够小的值作为函数参数时，应该按值（by-value）传入，而不是引用(by-ref)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gfud05-不要总是为函数指定-inlinealways"><a class="header" href="#gfud05-不要总是为函数指定-inlinealways">G.FUD.05 不要总是为函数指定 inline(always)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gfud06-函数参数应该考虑兼容多种类型"><a class="header" href="#gfud06-函数参数应该考虑兼容多种类型">G.FUD.06 函数参数应该考虑兼容多种类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="泛型"><a class="header" href="#泛型">泛型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pgen01-用泛型来抽象公共语义"><a class="header" href="#pgen01-用泛型来抽象公共语义">P.GEN.01 用泛型来抽象公共语义</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pgen02-不要随便使用-impl-trait-语法替代泛型限定"><a class="header" href="#pgen02-不要随便使用-impl-trait-语法替代泛型限定">P.GEN.02 不要随便使用 impl Trait 语法替代泛型限定</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pgen03-不要使用太多泛型参数和-trait-限定否则会增长编译时间"><a class="header" href="#pgen03-不要使用太多泛型参数和-trait-限定否则会增长编译时间">P.GEN.03 不要使用太多泛型参数和 trait 限定，否则会增长编译时间</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pgen04-为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到"><a class="header" href="#pgen04-为泛型类型实现方法时impl-中声明的泛型类型参数一定要被用到">P.GEN.04 为泛型类型实现方法时，impl 中声明的泛型类型参数一定要被用到</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pgen05-定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定"><a class="header" href="#pgen05-定义泛型函数时如果该函数实现用到来自-trait-定义的相关行为需要为泛型指定相关-trait-的限定">P.GEN.05 定义泛型函数时，如果该函数实现用到来自 trait 定义的相关行为，需要为泛型指定相关 trait 的限定</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ggen01-不要在泛型位置上使用内建类型"><a class="header" href="#ggen01-不要在泛型位置上使用内建类型">G.GEN.01 不要在泛型位置上使用内建类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ggen02-使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现"><a class="header" href="#ggen02-使用-rust-标准库中某些方法要注意避免使用其泛型默认实现而应该使用具体类型的实现">G.GEN.02 使用 Rust 标准库中某些方法，要注意避免使用其泛型默认实现，而应该使用具体类型的实现</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特质"><a class="header" href="#特质">特质</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptra01-使用-trait-时要注意-trait-一致性规则"><a class="header" href="#ptra01-使用-trait-时要注意-trait-一致性规则">P.TRA.01 使用 trait 时要注意 trait 一致性规则</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="标准库内置-trait"><a class="header" href="#标准库内置-trait">标准库内置 trait</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptrabln01-在实现borrow特质时需要注意一致性"><a class="header" href="#ptrabln01-在实现borrow特质时需要注意一致性">P.TRA.BLN.01 在实现Borrow特质时，需要注意一致性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln01-应该具体类型的-default-方法代替-defaultdefault-调用"><a class="header" href="#gtrabln01-应该具体类型的-default-方法代替-defaultdefault-调用">G.TRA.BLN.01 应该具体类型的 default() 方法代替 Default::default() 调用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln02-不要为迭代器实现copy-特质"><a class="header" href="#gtrabln02-不要为迭代器实现copy-特质">G.TRA.BLN.02 不要为迭代器实现Copy 特质</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln03-能使用派生宏derive自动实现default特质就不要用手工实现"><a class="header" href="#gtrabln03-能使用派生宏derive自动实现default特质就不要用手工实现">G.TRA.BLN.03 能使用派生宏（Derive）自动实现Default特质就不要用手工实现</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln04-在使用derivehash-的时候避免再手工实现-partialeq"><a class="header" href="#gtrabln04-在使用derivehash-的时候避免再手工实现-partialeq">G.TRA.BLN.04 在使用#[derive(Hash)] 的时候，避免再手工实现 PartialEq</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln05-在使用deriveord-的时候避免再手工实现-partialord"><a class="header" href="#gtrabln05-在使用deriveord-的时候避免再手工实现-partialord">G.TRA.BLN.05 在使用#[derive(Ord)] 的时候，避免再手工实现 PartialOrd</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln06-不要对实现-copy-或引用类型调用-stdmemdrop-和-stdmemforgot"><a class="header" href="#gtrabln06-不要对实现-copy-或引用类型调用-stdmemdrop-和-stdmemforgot">G.TRA.BLN.06 不要对实现 Copy 或引用类型调用 std::mem::drop 和 std::mem::forgot</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln07-对实现-copy-的可迭代类型来说要通过迭代器拷贝其所有元素时应该使用-copied方法而非cloned"><a class="header" href="#gtrabln07-对实现-copy-的可迭代类型来说要通过迭代器拷贝其所有元素时应该使用-copied方法而非cloned">G.TRA.BLN.07 对实现 Copy 的可迭代类型来说，要通过迭代器拷贝其所有元素时，应该使用 copied方法，而非cloned</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln08-实现-from-而不是-into"><a class="header" href="#gtrabln08-实现-from-而不是-into">G.TRA.BLN.08 实现 From 而不是 Into</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln09-一般情况下不要给-copy-类型手工实现-clone"><a class="header" href="#gtrabln09-一般情况下不要给-copy-类型手工实现-clone">G.TRA.BLN.09 一般情况下不要给 Copy 类型手工实现 Clone</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gtrabln10-不要随便使用deref特质来模拟继承"><a class="header" href="#gtrabln10-不要随便使用deref特质来模拟继承">G.TRA.BLN.10 不要随便使用Deref特质来模拟继承</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-对象"><a class="header" href="#trait-对象">trait 对象</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptraobj01-根据场景合理选择使用trait对象或泛型静态分发"><a class="header" href="#ptraobj01-根据场景合理选择使用trait对象或泛型静态分发">P.TRA.OBJ.01 根据场景合理选择使用trait对象或泛型静态分发</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ptraobj02-除非必要避免自定义虚表"><a class="header" href="#ptraobj02-除非必要避免自定义虚表">P.TRA.OBJ.02 除非必要，避免自定义虚表</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="错误处理"><a class="header" href="#错误处理">错误处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="perr01-当传入函数的参数值因为超出某种限制可能会导致函数调用失败应该使用断言"><a class="header" href="#perr01-当传入函数的参数值因为超出某种限制可能会导致函数调用失败应该使用断言">P.ERR.01 当传入函数的参数值因为超出某种限制可能会导致函数调用失败，应该使用断言</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="perr02-在确定-option-和-resultt-e类型的值不可能是-none-或-err-时请用-expect-代替-unwrap"><a class="header" href="#perr02-在确定-option-和-resultt-e类型的值不可能是-none-或-err-时请用-expect-代替-unwrap">P.ERR.02 在确定 Option 和 Result&lt;T, E&gt;类型的值不可能是 None 或 Err 时，请用 expect 代替 unwrap()</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gerr01-在处理-option-和-resultt-e-类型时不要随便使用-unwrap"><a class="header" href="#gerr01-在处理-option-和-resultt-e-类型时不要随便使用-unwrap">G.ERR.01 在处理 Option 和 Result&lt;T, E&gt; 类型时，不要随便使用 unwrap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gerr02-不要滥用-expect请考虑用-unwrap_or_-系列方法代替"><a class="header" href="#gerr02-不要滥用-expect请考虑用-unwrap_or_-系列方法代替">G.ERR.02 不要滥用 expect，请考虑用 unwrap_or_ 系列方法代替</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存管理"><a class="header" href="#内存管理">内存管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="生命周期"><a class="header" href="#生命周期">生命周期</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmemlft01-生命周期参数命名尽量有意义且简洁"><a class="header" href="#pmemlft01-生命周期参数命名尽量有意义且简洁">P.MEM.LFT.01 生命周期参数命名尽量有意义且简洁</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmemlft02-通常需要显式地标注生命周期而非利用编译器推断"><a class="header" href="#pmemlft02-通常需要显式地标注生命周期而非利用编译器推断">P.MEM.LFT.02 通常需要显式地标注生命周期，而非利用编译器推断</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="智能指针"><a class="header" href="#智能指针">智能指针</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmemspt01-使用-refcell-时宜使用-try_borrowtry_borrow_mut-方法"><a class="header" href="#pmemspt01-使用-refcell-时宜使用-try_borrowtry_borrow_mut-方法">P.MEM.SPT.01 使用 RefCell<T> 时宜使用 try_borrow/try_borrow_mut 方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box-类型"><a class="header" href="#box-类型">Box 类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmembox01-一般情况下不应直接对-box-进行借用"><a class="header" href="#gmembox01-一般情况下不应直接对-box-进行借用">G.MEM.BOX.01 一般情况下，不应直接对 Box<T> 进行借用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmembox02-一般情况下不应直接对已经在堆上分配内存的类型进行-box-装箱"><a class="header" href="#gmembox02-一般情况下不应直接对已经在堆上分配内存的类型进行-box-装箱">G.MEM.BOX.02 一般情况下，不应直接对已经在堆上分配内存的类型进行 Box 装箱</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmembox03-一般情况下不应直接对栈分配类型进行-box-装箱"><a class="header" href="#gmembox03-一般情况下不应直接对栈分配类型进行-box-装箱">G.MEM.BOX.03 一般情况下，不应直接对栈分配类型进行 Box 装箱</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop-析构"><a class="header" href="#drop-析构">Drop 析构</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmemdrp01-要注意防范内存泄漏"><a class="header" href="#gmemdrp01-要注意防范内存泄漏">G.MEM.DRP.01 要注意防范内存泄漏</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模块"><a class="header" href="#模块">模块</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmod01-合理控制对外接口和模块之间的可见性"><a class="header" href="#pmod01-合理控制对外接口和模块之间的可见性">P.MOD.01 合理控制对外接口和模块之间的可见性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmod02-将模块的测试移动到单独的文件有助于增加编译速度"><a class="header" href="#pmod02-将模块的测试移动到单独的文件有助于增加编译速度">P.MOD.02 将模块的测试移动到单独的文件，有助于增加编译速度</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmod01-使用导入模块中的类型或函数在某些情况下需要带模块名前缀"><a class="header" href="#gmod01-使用导入模块中的类型或函数在某些情况下需要带模块名前缀">G.MOD.01 使用导入模块中的类型或函数，在某些情况下需要带模块名前缀</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmod02-如果是作为库供别人使用在-librs中重新导出对外类型函数和-trait-等"><a class="header" href="#gmod02-如果是作为库供别人使用在-librs中重新导出对外类型函数和-trait-等">G.MOD.02 如果是作为库供别人使用，在 lib.rs中重新导出对外类型、函数和 trait 等</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmod03-导入模块不要随便使用-通配符"><a class="header" href="#gmod03-导入模块不要随便使用-通配符">G.MOD.03 导入模块不要随便使用 通配符*</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmod04-一个项目中应该避免使用不同的模块布局风格"><a class="header" href="#gmod04-一个项目中应该避免使用不同的模块布局风格">G.MOD.04 一个项目中应该避免使用不同的模块布局风格</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmod05-不要在私有模块中设置其内部类型或函数方法为-pubcrate"><a class="header" href="#gmod05-不要在私有模块中设置其内部类型或函数方法为-pubcrate">G.MOD.05 不要在私有模块中设置其内部类型或函数方法为 pub(crate)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="包管理"><a class="header" href="#包管理">包管理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcar01-应该尽量把项目划分为合理的-crate-组合"><a class="header" href="#pcar01-应该尽量把项目划分为合理的-crate-组合">P.CAR.01 应该尽量把项目划分为合理的 crate 组合</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcar02-不要滥用-features"><a class="header" href="#pcar02-不要滥用-features">P.CAR.02 不要滥用 Features</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcar03-使用-cargo-features-来代替---cfg-条件编译参数"><a class="header" href="#pcar03-使用-cargo-features-来代替---cfg-条件编译参数">P.CAR.03 使用 cargo features 来代替 --cfg 条件编译参数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pcar04-如果可能的话使用-cfg-来代替-cfg"><a class="header" href="#pcar04-如果可能的话使用-cfg-来代替-cfg">P.CAR.04 如果可能的话，使用 cfg! 来代替 #[cfg]</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcar01-当项目是可执行程序而非库时建议使用-srcmainrs-和-srclibrs-模式"><a class="header" href="#gcar01-当项目是可执行程序而非库时建议使用-srcmainrs-和-srclibrs-模式">G.CAR.01 当项目是可执行程序而非库时，建议使用 src/main.rs 和 src/lib.rs 模式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcar02-crate-的-cargotoml-中应该包含必要的元信息"><a class="header" href="#gcar02-crate-的-cargotoml-中应该包含必要的元信息">G.CAR.02 Crate 的 Cargo.toml 中应该包含必要的元信息</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcar03-feature-命名应该避免否定式或多余的前后缀"><a class="header" href="#gcar03-feature-命名应该避免否定式或多余的前后缀">G.CAR.03 Feature 命名应该避免否定式或多余的前后缀</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gcar04-cargotoml-中依赖包版本不应使用通配符"><a class="header" href="#gcar04-cargotoml-中依赖包版本不应使用通配符">G.CAR.04 Cargo.toml 中依赖包版本不应使用通配符</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="宏"><a class="header" href="#宏">宏</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmac01-不要轻易使用宏"><a class="header" href="#pmac01-不要轻易使用宏">P.MAC.01 不要轻易使用宏</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmac02-实现宏语法的时候应该尽量贴近-rust-语法"><a class="header" href="#pmac02-实现宏语法的时候应该尽量贴近-rust-语法">P.MAC.02 实现宏语法的时候，应该尽量贴近 Rust 语法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmac01-dbg-宏只应该用于调试代码"><a class="header" href="#gmac01-dbg-宏只应该用于调试代码">G.MAC.01 dbg!() 宏只应该用于调试代码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmac02-使用宏时应该考虑宏展开会让编译文件膨胀的影响"><a class="header" href="#gmac02-使用宏时应该考虑宏展开会让编译文件膨胀的影响">G.MAC.02 使用宏时应该考虑宏展开会让编译文件膨胀的影响</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="声明宏"><a class="header" href="#声明宏">声明宏</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacdcl01-不要将声明宏内的变量作为外部变量使用"><a class="header" href="#pmacdcl01-不要将声明宏内的变量作为外部变量使用">P.MAC.DCL.01 不要将声明宏内的变量作为外部变量使用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacdcl02-在编写多个宏规则时应该先从匹配粒度最小的开始写"><a class="header" href="#pmacdcl02-在编写多个宏规则时应该先从匹配粒度最小的开始写">P.MAC.DCL.02 在编写多个宏规则时，应该先从匹配粒度最小的开始写</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacdcl03-不要在片段分类符跟随它不匹配的符号"><a class="header" href="#pmacdcl03-不要在片段分类符跟随它不匹配的符号">P.MAC.DCL.03 不要在片段分类符跟随它不匹配的符号</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacdcl04-匹配规则要精准不要模糊不清"><a class="header" href="#pmacdcl04-匹配规则要精准不要模糊不清">P.MAC.DCL.04 匹配规则要精准，不要模糊不清</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacdcl05-使用宏替换substitution元变量的时候要注意选择合适的片段分类符"><a class="header" href="#pmacdcl05-使用宏替换substitution元变量的时候要注意选择合适的片段分类符">P.MAC.DCL.05 使用宏替换（substitution）元变量的时候要注意选择合适的片段分类符</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacdcl06-当宏需要接收-self-时需要注意"><a class="header" href="#pmacdcl06-当宏需要接收-self-时需要注意">P.MAC.DCL.06 当宏需要接收 self 时需要注意</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacdcl07-确保在宏定义之后再去调用宏"><a class="header" href="#pmacdcl07-确保在宏定义之后再去调用宏">P.MAC.DCL.07 确保在宏定义之后再去调用宏</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacdcl08-同一个-crate-内定义的宏相互调用时需要注意卫生性"><a class="header" href="#pmacdcl08-同一个-crate-内定义的宏相互调用时需要注意卫生性">P.MAC.DCL.08 同一个 crate 内定义的宏相互调用时，需要注意卫生性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="过程宏"><a class="header" href="#过程宏">过程宏</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacpro01-不要使用过程宏来规避静态分析检查"><a class="header" href="#pmacpro01-不要使用过程宏来规避静态分析检查">P.MAC.PRO.01 不要使用过程宏来规避静态分析检查</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacpro02-实现过程宏时要对关键特性增加测试"><a class="header" href="#pmacpro02-实现过程宏时要对关键特性增加测试">P.MAC.PRO.02 实现过程宏时要对关键特性增加测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacpro03-保证过程宏的卫生性"><a class="header" href="#pmacpro03-保证过程宏的卫生性">P.MAC.PRO.03 保证过程宏的卫生性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacpro04-给出正确的错误位置"><a class="header" href="#pmacpro04-给出正确的错误位置">P.MAC.PRO.04 给出正确的错误位置</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacpro05-代码生成要按情况选择使用过程宏还是-buildrs"><a class="header" href="#pmacpro05-代码生成要按情况选择使用过程宏还是-buildrs">P.MAC.PRO.05 代码生成要按情况选择使用过程宏还是 build.rs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmacpro06-buildrs-生成的代码要保证没有任何警告"><a class="header" href="#pmacpro06-buildrs-生成的代码要保证没有任何警告">P.MAC.PRO.06 build.rs 生成的代码要保证没有任何警告</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程"><a class="header" href="#多线程">多线程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="锁同步"><a class="header" href="#锁同步">锁同步</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmthlck01-多线程下要注意识别锁争用的情况避免死锁"><a class="header" href="#pmthlck01-多线程下要注意识别锁争用的情况避免死锁">P.MTH.LCK.01 多线程下要注意识别锁争用的情况，避免死锁</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmthlck01-对布尔或引用并发访问应该使用原子类型而非互斥锁"><a class="header" href="#gmthlck01-对布尔或引用并发访问应该使用原子类型而非互斥锁">G.MTH.LCK.01 对布尔或引用并发访问应该使用原子类型而非互斥锁</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmthlck02-宜使用-arc--arct-来代替-arc--arc"><a class="header" href="#gmthlck02-宜使用-arc--arct-来代替-arc--arc">G.MTH.LCK.02 宜使用 Arc / Arc&lt;[T]&gt; 来代替 Arc / Arc<Vec></a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmthlck03-尽量避免直接使用标准库-stdsync-模块中的同步原语替换为-parking_lot"><a class="header" href="#gmthlck03-尽量避免直接使用标准库-stdsync-模块中的同步原语替换为-parking_lot">G.MTH.LCK.03 尽量避免直接使用标准库 std::sync 模块中的同步原语，替换为 parking_lot</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gmthlck04-尽量避免直接使用标准库-stdsyncmpsc-模块中的-channel替换为-crossbeam"><a class="header" href="#gmthlck04-尽量避免直接使用标准库-stdsyncmpsc-模块中的-channel替换为-crossbeam">G.MTH.LCK.04 尽量避免直接使用标准库 std::sync::mpsc 模块中的 channel，替换为 crossbeam</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="无锁"><a class="header" href="#无锁">无锁</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmthlkf01-除非必要否则建议使用同步锁"><a class="header" href="#pmthlkf01-除非必要否则建议使用同步锁">P.MTH.LKF.01 除非必要，否则建议使用同步锁</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pmthlkf02-使用无锁编程时需要合理选择内存顺序"><a class="header" href="#pmthlkf02-使用无锁编程时需要合理选择内存顺序">P.MTH.LKF.02 使用无锁编程时，需要合理选择内存顺序</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步编程"><a class="header" href="#异步编程">异步编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pasy01-异步编程并不适合所有场景计算密集型场景应该考虑同步编程"><a class="header" href="#pasy01-异步编程并不适合所有场景计算密集型场景应该考虑同步编程">P.ASY.01 异步编程并不适合所有场景，计算密集型场景应该考虑同步编程</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gasy01-在-async-块或函数中调用-async-函数或闭包请不要忘记添加await"><a class="header" href="#gasy01-在-async-块或函数中调用-async-函数或闭包请不要忘记添加await">G.ASY.01 在 async 块或函数中调用 async 函数或闭包请不要忘记添加.await</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gasy02-在跨-await-调用中需要对其持有的同步互斥锁进行处理"><a class="header" href="#gasy02-在跨-await-调用中需要对其持有的同步互斥锁进行处理">G.ASY.02 在跨 await 调用中，需要对其持有的同步互斥锁进行处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gasy03-在跨-await-调用中需要对其持有-refcell-的引用进行处理"><a class="header" href="#gasy03-在跨-await-调用中需要对其持有-refcell-的引用进行处理">G.ASY.03 在跨 await 调用中，需要对其持有 RefCell 的引用进行处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gasy04-避免定义不必要的异步函数"><a class="header" href="#gasy04-避免定义不必要的异步函数">G.ASY.04 避免定义不必要的异步函数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gasy05-避免在异步处理过程中包含阻塞操作"><a class="header" href="#gasy05-避免在异步处理过程中包含阻塞操作">G.ASY.05 避免在异步处理过程中包含阻塞操作</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="puns01-不要为了逃避编译器安全检查而滥用-unsafe-rust"><a class="header" href="#puns01-不要为了逃避编译器安全检查而滥用-unsafe-rust">P.UNS.01 不要为了逃避编译器安全检查而滥用 Unsafe Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="puns02-不要为了提升性能而盲目使用-unsafe-rust"><a class="header" href="#puns02-不要为了提升性能而盲目使用-unsafe-rust">P.UNS.02 不要为了提升性能而盲目使用 Unsafe Rust</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guns01-不宜为带有-unsafe-命名的类型或方法创建别名"><a class="header" href="#guns01-不宜为带有-unsafe-命名的类型或方法创建别名">G.UNS.01 不宜为带有 unsafe 命名的类型或方法创建别名</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全抽象"><a class="header" href="#安全抽象">安全抽象</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punssas01-代码中要注意是否会因为-panic-发生而导致内存安全问题"><a class="header" href="#punssas01-代码中要注意是否会因为-panic-发生而导致内存安全问题">P.UNS.SAS.01 代码中要注意是否会因为 Panic 发生而导致内存安全问题</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punssas02-unsafe-代码编写者有义务检查代码是否满足安全不变式"><a class="header" href="#punssas02-unsafe-代码编写者有义务检查代码是否满足安全不变式">P.UNS.SAS.02 Unsafe 代码编写者有义务检查代码是否满足安全不变式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punssas03-不要随便在公开的-api-中暴露未初始化内存"><a class="header" href="#punssas03-不要随便在公开的-api-中暴露未初始化内存">P.UNS.SAS.03 不要随便在公开的 API 中暴露未初始化内存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punssas04-避免因为-panic-safety-而导致双重释放"><a class="header" href="#punssas04-避免因为-panic-safety-而导致双重释放">P.UNS.SAS.04 避免因为 Panic Safety 而导致双重释放</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punssas05-手动实现-auto-trait-时要充分考虑其安全性"><a class="header" href="#punssas05-手动实现-auto-trait-时要充分考虑其安全性">P.UNS.SAS.05 手动实现 auto trait 时要充分考虑其安全性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punssas06-不要随便在公开的-api-中暴露裸指针"><a class="header" href="#punssas06-不要随便在公开的-api-中暴露裸指针">P.UNS.SAS.06 不要随便在公开的 API 中暴露裸指针</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punssas07-在抽象安全方法的同时也建议为性能考虑而增加相应的-unsafe-方法"><a class="header" href="#punssas07-在抽象安全方法的同时也建议为性能考虑而增加相应的-unsafe-方法">P.UNS.SAS.07 在抽象安全方法的同时，也建议为性能考虑而增加相应的 Unsafe 方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punssas08-函数参数是不可变借用的时候返回值不应该是可变借用"><a class="header" href="#punssas08-函数参数是不可变借用的时候返回值不应该是可变借用">P.UNS.SAS.08 函数参数是不可变借用的时候，返回值不应该是可变借用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punssas09-在任何-unsafe-块之前都应该加-safety-注释"><a class="header" href="#punssas09-在任何-unsafe-块之前都应该加-safety-注释">P.UNS.SAS.09 在任何 Unsafe 块之前都应该加 SAFETY 注释</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gunssas01-在公开的-unsafe-函数的文档中必须增加-safety-注释"><a class="header" href="#gunssas01-在公开的-unsafe-函数的文档中必须增加-safety-注释">G.UNS.SAS.01 在公开的 unsafe 函数的文档中必须增加 Safety 注释</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gunssas02-在-unafe-函数中应使用-assert-而非-debug_assert-去校验边界条件"><a class="header" href="#gunssas02-在-unafe-函数中应使用-assert-而非-debug_assert-去校验边界条件">G.UNS.SAS.02 在 Unafe 函数中应使用 assert! 而非 debug_assert! 去校验边界条件</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="裸指针操作"><a class="header" href="#裸指针操作">裸指针操作</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsptr01-不要将裸指针在多线程间共享"><a class="header" href="#punsptr01-不要将裸指针在多线程间共享">P.UNS.PTR.01 不要将裸指针在多线程间共享</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsptr02-建议使用-nonnull-来替代-mut-t"><a class="header" href="#punsptr02-建议使用-nonnull-来替代-mut-t">P.UNS.PTR.02 建议使用 NonNull<T> 来替代 *mut T</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsptr03-使用指针类型构造泛型结构体时需要使用-phantomdata-来指定-t上的协变和所有权"><a class="header" href="#punsptr03-使用指针类型构造泛型结构体时需要使用-phantomdata-来指定-t上的协变和所有权">P.UNS.PTR.03 使用指针类型构造泛型结构体时，需要使用 PhantomData<T> 来指定 T上的协变和所有权</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gunsptr01-当指针类型被强转为和当前内存对齐不一致的指针类型时禁止对其解引用"><a class="header" href="#gunsptr01-当指针类型被强转为和当前内存对齐不一致的指针类型时禁止对其解引用">G.UNS.PTR.01 当指针类型被强转为和当前内存对齐不一致的指针类型时，禁止对其解引用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gunsptr02-禁止将不可变指针手工转换为可变指针"><a class="header" href="#gunsptr02-禁止将不可变指针手工转换为可变指针">G.UNS.PTR.02 禁止将不可变指针手工转换为可变指针</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gunsptr03-尽量使用-pointercast-来代替-使用-as-强转指针"><a class="header" href="#gunsptr03-尽量使用-pointercast-来代替-使用-as-强转指针">G.UNS.PTR.03 尽量使用 pointer::cast 来代替 使用 as 强转指针</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="联合体"><a class="header" href="#联合体">联合体</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsuni01-除了与-c-交互尽量不要使用-union"><a class="header" href="#punsuni01-除了与-c-交互尽量不要使用-union">P.UNS.UNI.01 除了与 C 交互，尽量不要使用 Union</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsuni02-不要把联合体的不同变体用在不同生命周期内"><a class="header" href="#punsuni02-不要把联合体的不同变体用在不同生命周期内">P.UNS.UNI.02 不要把联合体的不同变体用在不同生命周期内</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存"><a class="header" href="#内存">内存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsmem01-要注意选择合适的结构体元组枚举的数据布局"><a class="header" href="#punsmem01-要注意选择合适的结构体元组枚举的数据布局">P.UNS.MEM.01 要注意选择合适的结构体、元组、枚举的数据布局</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsmem02-不能修改其它进程或动态库的内存变量"><a class="header" href="#punsmem02-不能修改其它进程或动态库的内存变量">P.UNS.MEM.02 不能修改其它进程或动态库的内存变量</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsmem03-不能让-stringvec-自动-drop-其它进程或动态库的内存数据"><a class="header" href="#punsmem03-不能让-stringvec-自动-drop-其它进程或动态库的内存数据">P.UNS.MEM.03 不能让 String/Vec 自动 Drop 其它进程或动态库的内存数据</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsmem04-尽量用可重入reentrant版本的-c-api-或系统调用"><a class="header" href="#punsmem04-尽量用可重入reentrant版本的-c-api-或系统调用">P.UNS.MEM.04 尽量用可重入(reentrant)版本的 C-API 或系统调用</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsmem05-如果需要使用位域推荐使用第三方库"><a class="header" href="#punsmem05-如果需要使用位域推荐使用第三方库">P.UNS.MEM.05 如果需要使用位域，推荐使用第三方库</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gunsmem01-使用-maybeuninit-来处理未初始化的内存"><a class="header" href="#gunsmem01-使用-maybeuninit-来处理未初始化的内存">G.UNS.MEM.01 使用 MaybeUninit<T> 来处理未初始化的内存</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ffi"><a class="header" href="#ffi">FFi</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi01-避免从公开的-rust-api-直接传字符串到-c-中"><a class="header" href="#punsffi01-避免从公开的-rust-api-直接传字符串到-c-中">P.UNS.FFI.01 避免从公开的 Rust API 直接传字符串到 C 中</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi02-在使用标准库-stdffi-模块提供的类型时需要仔细查看其文档"><a class="header" href="#punsffi02-在使用标准库-stdffi-模块提供的类型时需要仔细查看其文档">P.UNS.FFI.02 在使用标准库 std::ffi 模块提供的类型时需要仔细查看其文档</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi03-当使用来自-c-的指针时如果该指针需要管理内存则需要为包装该指针的-rust-类型实现-drop-特质"><a class="header" href="#punsffi03-当使用来自-c-的指针时如果该指针需要管理内存则需要为包装该指针的-rust-类型实现-drop-特质">P.UNS.FFI.03 当使用来自 C 的指针时，如果该指针需要管理内存，则需要为包装该指针的 Rust 类型实现 Drop 特质</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi04-如果一个函数正在跨越-ffi-边界那么需要处理-panic"><a class="header" href="#punsffi04-如果一个函数正在跨越-ffi-边界那么需要处理-panic">P.UNS.FFI.04 如果一个函数正在跨越 FFi 边界，那么需要处理 Panic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi05-建议使用诸如标准库或-libc-crate-所提供的可移植类型别名而不是特定平台的类型"><a class="header" href="#punsffi05-建议使用诸如标准库或-libc-crate-所提供的可移植类型别名而不是特定平台的类型">P.UNS.FFI.05 建议使用诸如标准库或 libc crate 所提供的可移植类型别名，而不是特定平台的类型</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi06-rust-和-c-之间传递字符或字符串时需要注意字符串要符合-c-abi-以及-字符串的编码"><a class="header" href="#punsffi06-rust-和-c-之间传递字符或字符串时需要注意字符串要符合-c-abi-以及-字符串的编码">P.UNS.FFI.06 Rust 和 C 之间传递字符或字符串时需要注意字符串要符合 C-ABI 以及 字符串的编码</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi07-不要为任何传出外部的类型实现-drop"><a class="header" href="#punsffi07-不要为任何传出外部的类型实现-drop">P.UNS.FFI.07 不要为任何传出外部的类型实现 Drop</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi08-ffi-中要进行合理的错误处理"><a class="header" href="#punsffi08-ffi-中要进行合理的错误处理">P.UNS.FFI.08 FFi 中要进行合理的错误处理</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi09-当-rust-调用外部-c-函数时如果可以确认安全可以通过引用来代替裸指针"><a class="header" href="#punsffi09-当-rust-调用外部-c-函数时如果可以确认安全可以通过引用来代替裸指针">P.UNS.FFI.09 当 Rust 调用外部 C 函数时，如果可以确认安全，可以通过引用来代替裸指针</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi10-当-rust-函数导出外部函数时必须从设计上保证被跨线程调用的安全性"><a class="header" href="#punsffi10-当-rust-函数导出外部函数时必须从设计上保证被跨线程调用的安全性">P.UNS.FFI.10 当 Rust 函数导出外部函数时，必须从设计上保证被跨线程调用的安全性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi11-如需引用指定为-reprpacked-内存布局的结构体成员字段要注意合理规避未定义行为"><a class="header" href="#punsffi11-如需引用指定为-reprpacked-内存布局的结构体成员字段要注意合理规避未定义行为">P.UNS.FFI.11 如需引用指定为 #[repr(packed)] 内存布局的结构体成员字段要注意合理规避未定义行为</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi12-当依赖-c-端传入参数时需要在文档注释中不变性声明根据不同的调用场景选择合适的安全抽象方式"><a class="header" href="#punsffi12-当依赖-c-端传入参数时需要在文档注释中不变性声明根据不同的调用场景选择合适的安全抽象方式">P.UNS.FFI.12 当依赖 C 端传入参数时，需要在文档注释中不变性声明，根据不同的调用场景选择合适的安全抽象方式</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi13-自定义数据类型要保证一致的数据布局"><a class="header" href="#punsffi13-自定义数据类型要保证一致的数据布局">P.UNS.FFI.13 自定义数据类型要保证一致的数据布局</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi14-在-ffi-中使用的类型应该拥有稳定布局"><a class="header" href="#punsffi14-在-ffi-中使用的类型应该拥有稳定布局">P.UNS.FFI.14 在 FFi 中使用的类型应该拥有稳定布局</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsffi15-从外部传入的不健壮类型的外部值要进行检查"><a class="header" href="#punsffi15-从外部传入的不健壮类型的外部值要进行检查">P.UNS.FFI.15 从外部传入的不健壮类型的外部值要进行检查</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io"><a class="header" href="#io">I/O</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="punsfio01-在使用原始句柄的时候要注意-io-安全性"><a class="header" href="#punsfio01-在使用原始句柄的时候要注意-io-安全性">P.UNS.FIO.01 在使用原始句柄的时候，要注意 I/O 安全性</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-代码术语指南"><a class="header" href="#unsafe-代码术语指南">Unsafe 代码术语指南</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="no-std"><a class="header" href="#no-std">no-std</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pemb01-no-std-下必须定义一个panic行为以确保安全"><a class="header" href="#pemb01-no-std-下必须定义一个panic行为以确保安全">P.EMB.01 no-std 下必须定义一个Panic行为以确保安全</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pemb02-no-std-下要确保程序中的类型有正确的内存布局"><a class="header" href="#pemb02-no-std-下要确保程序中的类型有正确的内存布局">P.EMB.02 no-std 下要确保程序中的类型有正确的内存布局</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="io-1"><a class="header" href="#io-1">I/O</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pfio01-使用-read_to_endread_to_string方法时注意文件的大小能否一次性读入内存中"><a class="header" href="#pfio01-使用-read_to_endread_to_string方法时注意文件的大小能否一次性读入内存中">P.FIO.01 使用 read_to_end/read_to_string方法时注意文件的大小能否一次性读入内存中</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gfio01-文件读取建议使用-bufreaderbufwriter-来代替-readerwrite"><a class="header" href="#gfio01-文件读取建议使用-bufreaderbufwriter-来代替-readerwrite">G.FIO.01 文件读取建议使用 BufReader/BufWriter 来代替 Reader/Write</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信息安全"><a class="header" href="#信息安全">信息安全</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="psec01-使用第三方库的时候要确保可信的依赖小心供应链攻击"><a class="header" href="#psec01-使用第三方库的时候要确保可信的依赖小心供应链攻击">P.SEC.01 使用第三方库的时候要确保可信的依赖，小心供应链攻击</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gsec01-代码中不要出现非法-unicode-字符也要防范非法-unicode-字符"><a class="header" href="#gsec01-代码中不要出现非法-unicode-字符也要防范非法-unicode-字符">G.SEC.01 代码中不要出现非法 Unicode 字符，也要防范非法 Unicode 字符</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他"><a class="header" href="#其他">其他</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goth01-对于某些场景下不建议使用的方法可以通过配置-clippytoml-来拒绝"><a class="header" href="#goth01-对于某些场景下不建议使用的方法可以通过配置-clippytoml-来拒绝">G.OTH.01 对于某些场景下不建议使用的方法可以通过配置 clippy.toml 来拒绝</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goth01-使用标准库中对应的方法计算秒级毫秒级微秒级的时间"><a class="header" href="#goth01-使用标准库中对应的方法计算秒级毫秒级微秒级的时间">G.OTH.01 使用标准库中对应的方法计算秒级、毫秒级、微秒级的时间</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a开发环境"><a class="header" href="#a开发环境">A.开发环境</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b测试"><a class="header" href="#b测试">B.测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单元测试"><a class="header" href="#单元测试">单元测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="基准测试"><a class="header" href="#基准测试">基准测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="模糊测试"><a class="header" href="#模糊测试">模糊测试</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c术语解释"><a class="header" href="#c术语解释">C.术语解释</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="d模板"><a class="header" href="#d模板">D.模板</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt-模板"><a class="header" href="#rustfmt-模板">rustfmt 模板</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy-模板"><a class="header" href="#clippy-模板">clippy 模板</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deny-模板"><a class="header" href="#deny-模板">deny 模板</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="e工具链"><a class="header" href="#e工具链">E.工具链</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustfmt"><a class="header" href="#rustfmt">rustfmt</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="noisy-clippy"><a class="header" href="#noisy-clippy">noisy-clippy</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-udeps"><a class="header" href="#cargo-udeps">cargo-udeps</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fcheat-sheet"><a class="header" href="#fcheat-sheet">F.Cheat Sheet</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="浮点数-1"><a class="header" href="#浮点数-1">浮点数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="g优化指南"><a class="header" href="#g优化指南">G.优化指南</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="h编译参数说明"><a class="header" href="#h编译参数说明">H.编译参数说明</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="i最佳实践"><a class="header" href="#i最佳实践">I.最佳实践</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="初学者常见问题qa"><a class="header" href="#初学者常见问题qa">初学者常见问题Q&amp;A</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-编程技巧"><a class="header" href="#rust-编程技巧">Rust 编程技巧</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="j贡献说明"><a class="header" href="#j贡献说明">J.贡献说明</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
